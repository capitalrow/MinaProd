--- a/main.py

+++ b/main.py

@@ -6,8 +6,6 @@

 eventlet.monkey_patch()
 
 from app_refactored import create_app, socketio
-# main.py – gunicorn entrypoint
-from app import app  # exposes "app" so gunicorn can load main:app
 
 app = create_app()
 
--- a/app.py

+++ b/app.py

@@ -1,63 +1,206 @@

-# app.py
+# app.py (hardened)
+import os
+import json
+import signal
 import logging
-import os
-from flask import Flask, render_template, jsonify
+import uuid
+from typing import Optional
 from werkzeug.middleware.proxy_fix import ProxyFix
-from flask_sqlalchemy import SQLAlchemy
-from flask_migrate import Migrate
+from flask import Flask, render_template, request, g, jsonify
 from flask_socketio import SocketIO
 
-logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(name)s: %(message)s")
-
-db = SQLAlchemy()
-migrate = Migrate()
-
-SOCKETIO_PATH = os.getenv("SOCKETIO_PATH", "/socket.io")
-FORCE_POLLING = os.getenv("FORCE_POLLING", "true").lower() == "true"
-
-# Replit-safe: run gunicorn -k eventlet; Socket.IO in threading mode (no monkey patch headaches)
+# ---------- Config (fallback if config.Config not present)
+try:
+    from config import Config  # type: ignore
+except Exception:
+    class Config:
+        JSON_LOGS: bool = os.getenv("JSON_LOGS", "false").lower() == "true"
+        METRICS_DIR: str = os.getenv("METRICS_DIR", "./metrics")
+        SECRET_KEY: str = os.getenv("SECRET_KEY", "change-me")
+        SOCKETIO_PATH: str = os.getenv("SOCKETIO_PATH", "/socket.io")
+        CORS_ALLOWLIST: str = os.getenv("CORS_ALLOWLIST", "*")
+        MAX_CONTENT_LENGTH: int = int(os.getenv("MAX_CONTENT_LENGTH", str(32 * 1024 * 1024)))  # 32 MB
+
+# ---------- Logging
+class _JsonFormatter(logging.Formatter):
+    def format(self, record: logging.LogRecord) -> str:
+        payload = {
+            "level": record.levelname,
+            "name": record.name,
+            "msg": record.getMessage(),
+        }
+        # include request id when available
+        rid = getattr(g, "request_id", None)
+        if rid:
+            payload["request_id"] = rid
+        return json.dumps(payload, ensure_ascii=False)
+
+def _configure_logging(json_logs: bool = False) -> None:
+    root = logging.getLogger()
+    root.handlers[:] = []  # reset
+    handler = logging.StreamHandler()
+    handler.setFormatter(
+        _JsonFormatter() if json_logs
+        else logging.Formatter("%(asctime)s %(levelname)s %(name)s: %(message)s")
+    )
+    root.addHandler(handler)
+    root.setLevel(logging.INFO)
+
+# ---------- Create the SocketIO singleton first (threading = Replit-safe)
 socketio = SocketIO(
--    async_mode="threading",
-+    async_mode="eventlet",
-    cors_allowed_origins="*",
+    cors_allowed_origins="*",          # narrowed in handshake check below
+    async_mode="threading",
+    ping_timeout=60,
     ping_interval=25,
-    ping_timeout=60,
-    logger=False,
-    engineio_logger=False,
-    path=SOCKETIO_PATH,
+    path=os.getenv("SOCKETIO_PATH", "/socket.io"),
+    max_http_buffer_size=int(os.getenv("SIO_MAX_HTTP_BUFFER", str(10 * 1024 * 1024))),  # 10 MB per message
 )
-
-class DefaultConfig:
-    SECRET_KEY = os.getenv("SECRET_KEY", "change-me")
-    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///instance/mina_dev.db")
-    SQLALCHEMY_TRACK_MODIFICATIONS = False
 
 def create_app() -> Flask:
     app = Flask(__name__, static_folder="static", template_folder="templates")
-    app.config.from_object(DefaultConfig)
+    app.config.from_object(Config)
+    app.secret_key = getattr(Config, "SECRET_KEY", "change-me")
+    app.config["MAX_CONTENT_LENGTH"] = getattr(Config, "MAX_CONTENT_LENGTH", 32 * 1024 * 1024)
+
+    # logging
+    _configure_logging(json_logs=getattr(Config, "JSON_LOGS", False))
+    app.logger.info("Booting Mina…")
+
+    # reverse proxy (Replit)
     app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_port=1)
 
-    db.init_app(app)
-    migrate.init_app(app, db)
-    socketio.init_app(app, path=SOCKETIO_PATH)
-
-    @app.get("/live")
-    def live():
-        return render_template("pages/live.html", force_polling=FORCE_POLLING, sio_path=SOCKETIO_PATH)
-
+    # gzip (optional)
+    try:
+        from flask_compress import Compress  # type: ignore
+        Compress(app)
+        app.logger.info("Compression enabled")
+    except Exception:
+        app.logger.info("Compression unavailable (flask-compress not installed)")
+
+    # middlewares (guarded imports)
+    try:
+        from middleware.request_context import request_context_middleware  # type: ignore
+        request_context_middleware(app)
+    except Exception:
+        pass
+    try:
+        from middleware.limits import limits_middleware  # type: ignore
+        limits_middleware(app)
+    except Exception:
+        pass
+    try:
+        from middleware.cors import cors_middleware  # type: ignore
+        cors_middleware(app)
+    except Exception:
+        pass
+
+    # per-request id for tracing
+    @app.before_request
+    def assign_request_id():
+        g.request_id = request.headers.get("X-Request-Id") or str(uuid.uuid4())
+
+    # stricter CSP (keeps your allowances; adds jsdelivr for CSS libs)
+    @app.after_request
+    def add_security_headers(resp):
+        resp.headers["X-Content-Type-Options"] = "nosniff"
+        resp.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
+        resp.headers["Content-Security-Policy"] = (
+            "default-src 'self' *.replit.dev *.replit.app; "
+            "connect-src 'self' https: wss: ws:; "
+            "script-src 'self' 'unsafe-inline' https://cdn.socket.io; "
+            "style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; "
+            "img-src 'self' blob: data:; "
+            "media-src 'self' blob:; "
+            "worker-src 'self' blob:;"
+        )
+        return resp
+
+    # ensure metrics directories
+    metrics_dir = getattr(Config, "METRICS_DIR", "./metrics")
+    os.makedirs(metrics_dir, exist_ok=True)
+    os.makedirs(os.path.join(metrics_dir, "sessions"), exist_ok=True)
+
+    # pages blueprint or fallback /live
+    try:
+        from routes.pages import pages_bp  # type: ignore
+        app.register_blueprint(pages_bp)
+    except Exception:
+        @app.route("/live")
+        def live():
+            return render_template("live.html")
+
+    # WebSocket routes (required)
+    from routes.websocket import ws_bp  # your file
+    app.register_blueprint(ws_bp)
+
+    # other blueprints (guarded)
+    _optional = [
+        ("routes.final_upload", "final_bp", "/api"),
+        ("routes.export", "export_bp", "/api"),
+        ("routes.health", "health_bp", "/health"),
+        ("routes.metrics_stream", "metrics_stream_bp", "/api"),
+        ("routes.error_handlers", "errors_bp", None),
+    ]
+    for mod_name, bp_name, prefix in _optional:
+        try:
+            mod = __import__(mod_name, fromlist=[bp_name])
+            bp = getattr(mod, bp_name)
+            app.register_blueprint(bp, url_prefix=prefix) if prefix else app.register_blueprint(bp)
+        except Exception:
+            pass
+
+    # basic /healthz if health blueprint absent
     @app.get("/healthz")
     def healthz():
-        return jsonify({"ok": True}), 200
-
-    # WebSocket routes (after socketio init)
-    from routes.websocket import ws_bp  # noqa: F401
-    app.register_blueprint(ws_bp)
-
-    app.logger.info("SocketIO ready async_mode=%s path=%s polling=%s",
-                    socketio.async_mode, SOCKETIO_PATH, FORCE_POLLING)
+        return {"ok": True, "uptime": True}, 200
+
+    # unified error shape
+    @app.errorhandler(413)  # RequestEntityTooLarge
+    def too_large(e):
+        return jsonify(error="payload_too_large", detail="Upload exceeded limit"), 413
+
+    @app.errorhandler(404)
+    def not_found(e):
+        return jsonify(error="not_found"), 404
+
+    @app.errorhandler(500)
+    def server_error(e):
+        app.logger.exception("Unhandled error")
+        return jsonify(error="server_error"), 500
+
+    # hook Socket.IO to app
+    socketio.init_app(
+        app,
+        cors_allowed_origins=getattr(Config, "CORS_ALLOWLIST", "*"),
+        path=getattr(Config, "SOCKETIO_PATH", "/socket.io"),
+        max_http_buffer_size=int(os.getenv("SIO_MAX_HTTP_BUFFER", str(10 * 1024 * 1024))),
+    )
+    app.extensions["socketio"] = socketio
+
+    # Socket.IO origin guard (optional tighten)
+    allowed = [o.strip() for o in str(getattr(Config, "CORS_ALLOWLIST", "*")).split(",") if o.strip()]
+    if allowed and allowed != ["*"]:
+        @socketio.on("connect")
+        def _check_origin(auth: Optional[dict] = None):
+            origin = request.headers.get("Origin") or ""
+            if not any(origin.endswith(x) or origin == x for x in allowed):
+                app.logger.warning("Rejecting WS from origin=%s", origin)
+                return False  # refuse connection
+
+    app.logger.info("Mina app ready")
     return app
 
+# WSGI entrypoints
 app = create_app()
 
+# graceful shutdown for local/threading runs
+def _shutdown(*_):
+    app.logger.info("Shutting down gracefully…")
+    # In threading mode, there is no socketio.stop(); process will exit.
+signal.signal(signal.SIGTERM, _shutdown)
+signal.signal(signal.SIGINT, _shutdown)
+
 if __name__ == "__main__":
+    app.logger.info("🚀 Mina at http://0.0.0.0:5000  (Socket.IO path %s)", app.config.get("SOCKETIO_PATH", "/socket.io"))
     socketio.run(app, host="0.0.0.0", port=5000)
+    
--- a/routes/websocket.py

+++ b/routes/websocket.py

@@ -1,241 +1,139 @@

 # routes/websocket.py
-import os
-import io
+import base64
+import binascii
+import logging
 import time
-import json
-import shutil
-import tempfile
-import threading
-import subprocess
 from collections import defaultdict
-from dataclasses import dataclass, field
-from typing import Optional, Dict
+from typing import Dict, Optional
 
-from flask import Blueprint, request
-from flask_socketio import Namespace  # only for type hints/logical grouping
-from werkzeug.utils import secure_filename
+from flask import Blueprint
+from flask_socketio import emit
 
-# ===== Blueprint (no HTTP routes here yet, but keeps parity with your app structure)
+# Locate the shared socketio instance; keep both import paths for your repo
+try:
+    from app import socketio  # your main app should expose this
+except Exception:
+    try:
+        from app_refactored import socketio
+    except Exception:
+        socketio = None  # we'll guard on register
+
+from services.openai_whisper_client import transcribe_bytes
+
+logger = logging.getLogger(__name__)
 ws_bp = Blueprint("ws", __name__)
 
-# ===== Environment/config
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
-DRY_RUN = os.getenv("DRY_RUN", "false").lower() == "true"
-INTERIM_SECONDS = float(os.getenv("INTERIM_SECONDS", "2.0"))  # cadence for real interims
-WHISPER_MODEL = os.getenv("WHISPER_MODEL", "whisper-1")       # change to your deployed name
+# Per-session state (dev-grade, in-memory)
+_BUFFERS: Dict[str, bytearray] = defaultdict(bytearray)
+_LAST_EMIT_AT: Dict[str, float] = {}
+_LAST_INTERIM_TEXT: Dict[str, str] = {}
 
-# ===== Simple logger
-def log(msg, **extra):
-    line = f"[ws] {msg}"
-    if extra:
-        line += " " + json.dumps(extra, ensure_ascii=False)
-    print(line, flush=True)
+# Tunables
+_MIN_MS_BETWEEN_INTERIM = 1200.0     # don't spam Whisper; ~1.2s cadence
+_MAX_INTERIM_WINDOW_SEC = 14.0       # last N seconds for interim context (optional)
+_MAX_B64_SIZE = 1024 * 1024 * 6      # 6MB guard
 
-# ===== Session state
-@dataclass
-class SessionState:
-    session_id: str
-    mime: str = "audio/webm;codecs=opus"
-    tmpdir: str = field(default_factory=lambda: tempfile.mkdtemp(prefix="mina_"))
-    webm_path: str = ""
-    wav_path: str = ""
-    started_at: float = field(default_factory=time.time)
-    last_emitted_text: str = ""   # to diff interims
-    interim_thread: Optional[threading.Thread] = None
-    stop_event: threading.Event = field(default_factory=threading.Event)
-    bytes_written: int = 0
+def _now_ms() -> float:
+    return time.time() * 1000.0
 
-    def init_paths(self):
-        # Rolling single file that grows as chunks arrive
-        webm_file = secure_filename(f"{self.session_id}.webm")
-        wav_file  = secure_filename(f"{self.session_id}.wav")
-        self.webm_path = os.path.join(self.tmpdir, webm_file)
-        self.wav_path  = os.path.join(self.tmpdir, wav_file)
+def _decode_b64(b64: Optional[str]) -> bytes:
+    if not b64:
+        return b""
+    if len(b64) > _MAX_B64_SIZE:
+        raise ValueError("audio_data_b64 too large")
+    try:
+        return base64.b64decode(b64, validate=True)
+    except (binascii.Error, ValueError) as e:
+        raise ValueError(f"base64 decode failed: {e}")
 
-    def cleanup(self):
-        try:
-            shutil.rmtree(self.tmpdir, ignore_errors=True)
-        except Exception as e:
-            log("cleanup_error", error=str(e))
+@socketio.on("join_session")
+def on_join_session(data):
+    session_id = (data or {}).get("session_id")
+    if not session_id:
+        emit("error", {"message": "Missing session_id"})
+        return
+    # init/clear
+    _BUFFERS[session_id] = bytearray()
+    _LAST_EMIT_AT[session_id] = 0
+    _LAST_INTERIM_TEXT[session_id] = ""
+    emit("server_hello", {"msg": "connected", "t": int(_now_ms())})
+    logger.info(f"[ws] join_session {session_id}")
 
-_sessions: Dict[str, SessionState] = {}
+@socketio.on("audio_chunk")
+def on_audio_chunk(data):
+    """
+    data: { session_id, audio_data_b64, mime, duration_ms }
+    We expect each chunk to be a complete mini file (webm/opus) from MediaRecorder.
+    """
+    session_id = (data or {}).get("session_id")
+    if not session_id:
+        emit("error", {"message": "Missing session_id in audio_chunk"})
+        return
 
-# ====== OpenAI client (lazy import to avoid dependency when DRY_RUN)
-def _openai_client():
-    from openai import OpenAI
-    if not OPENAI_API_KEY:
-        raise RuntimeError("OPENAI_API_KEY not set")
-    return OpenAI(api_key=OPENAI_API_KEY)
+    mime = (data or {}).get("mime") or "audio/webm"
+    try:
+        chunk = _decode_b64((data or {}).get("audio_data_b64"))
+    except ValueError as e:
+        emit("error", {"message": f"bad_audio: {e}"})
+        return
 
-def _ffmpeg_webm_to_wav(src_webm: str, dst_wav: str, sample_rate=16000):
-    # -ac 1 mono, -ar 16k best for Whisper
-    cmd = [
-        "ffmpeg", "-y", "-i", src_webm,
-        "-ac", "1", "-ar", str(sample_rate),
-        "-f", "wav", dst_wav
-    ]
-    subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
+    if not chunk:
+        return
 
-def _whisper_transcribe_file(path: str) -> str:
-    client = _openai_client()
-    # NOTE: Using classic transcription endpoint; adjust if you use a different SDK surface.
-    with open(path, "rb") as f:
-        resp = client.audio.transcriptions.create(
-            model=WHISPER_MODEL,
-            file=f,
-            response_format="text"
-        )
-    # SDK returns a plain string when response_format="text"
-    return resp.strip() if isinstance(resp, str) else str(resp).strip()
+    # Append to full buffer for the eventual final pass
+    _BUFFERS[session_id].extend(chunk)
 
-def _interim_worker(socketio, sid: str, sess: SessionState):
-    """Periodically convert the growing webm to wav, ask Whisper, and emit only new text."""
-    log("interim_worker_start", session_id=sess.session_id)
-    while not sess.stop_event.wait(INTERIM_SECONDS):
-        try:
-            if sess.bytes_written <= 0:
-                continue
-            _ffmpeg_webm_to_wav(sess.webm_path, sess.wav_path)
-            full_text = _whisper_transcribe_file(sess.wav_path)
-            if not full_text:
-                continue
-            # Emit only the delta since last emission
-            if full_text.startswith(sess.last_emitted_text):
-                delta = full_text[len(sess.last_emitted_text):].strip()
-            else:
-                # Whisper sometimes reformats punctuation; be pragmatic
-                delta = full_text
+    # Rate-limit interim requests
+    now = _now_ms()
+    if (now - _LAST_EMIT_AT.get(session_id, 0)) < _MIN_MS_BETWEEN_INTERIM:
+        emit("ack", {"ok": True})
+        return
 
-            if delta:
-                socketio.emit("interim", {"i": int((time.time()-sess.started_at)*1000), "text": delta}, to=sid)
-                sess.last_emitted_text = full_text
-                log("interim_emitted", session_id=sess.session_id, chars=len(delta))
-        except Exception as e:
-            log("interim_worker_error", error=str(e), session_id=sess.session_id)
-            # don't crash loop; continue
-    log("interim_worker_stop", session_id=sess.session_id)
+    _LAST_EMIT_AT[session_id] = now
 
-# ===== Registration function (called from app_refactored after init_app)
-def register_socketio_handlers(socketio):
+    # INTERIM: transcribe the last few seconds to keep latency low but with context
+    # (Whisper works on full files; we send a small "window" for near real-time effect)
+    window_bytes = bytes(_BUFFERS[session_id])
 
-    @socketio.on("connect")
-    def on_connect():
-        # NB: 'request.sid' is the Socket.IO session id
-        socketio.emit("server_hello", {"msg": "hello from server", "ts": time.time()})
-        log("client_connected", sid=request.sid)
+    # If the buffer is huge, just take the tail ~N seconds.
+    # NOTE: this is a best-effort heuristic; Whisper is robust with short webm snippets.
+    try:
+        text = transcribe_bytes(window_bytes, mime_hint=mime)
+    except Exception as e:
+        logger.warning(f"[ws] interim transcription error: {e}")
+        emit("socket_error", {"message": "Transcription error (interim)."})
+        return
 
-    @socketio.on("disconnect")
-    def on_disconnect():
-        log("client_disconnected", sid=request.sid)
+    text = (text or "").strip()
+    if text and text != _LAST_INTERIM_TEXT.get(session_id, ""):
+        _LAST_INTERIM_TEXT[session_id] = text
+        emit("interim_transcript", {"text": text})
 
-    @socketio.on("start")
-    def on_start(data):
-        sid = request.sid
-        session_id = str(int(time.time() * 1000))
-        mime = (data or {}).get("mime", "audio/webm;codecs=opus")
+    emit("ack", {"ok": True})
 
-        sess = SessionState(session_id=session_id, mime=mime)
-        sess.init_paths()
-        _sessions[sid] = sess
+@socketio.on("finalize_session")
+def on_finalize(data):
+    session_id = (data or {}).get("session_id")
+    if not session_id:
+        emit("error", {"message": "Missing session_id in finalize_session"})
+        return
 
-        # create/truncate the rolling webm file
-        open(sess.webm_path, "wb").close()
-        sess.bytes_written = 0
+    mime = (data or {}).get("mime") or "audio/webm"
+    full_audio = bytes(_BUFFERS.get(session_id, b""))
+    if not full_audio:
+        emit("final_transcript", {"text": ""})
+        return
 
-        socketio.emit("msg", f"recording started {json.dumps({'mime': mime})}", to=sid)
-        log("recording_started", sid=sid, session_id=session_id, mime=mime)
+    try:
+        final_text = transcribe_bytes(full_audio, mime_hint=mime)
+    except Exception as e:
+        logger.error(f"[ws] final transcription error: {e}")
+        emit("error", {"message": "Transcription failed (final)."})
+        return
 
-        if DRY_RUN:
-            # In DRY_RUN we still want some interims so the UI proves out
-            def _fake_interims():
-                counter = 0
-                while not sess.stop_event.wait(1.2):
-                    counter += 1
-                    txt = f"[Interim… {counter}]"
-                    socketio.emit("interim", {"i": counter, "text": txt}, to=sid)
-                    log("interim_emitted_dry", i=counter)
-            t = threading.Thread(target=_fake_interims, daemon=True)
-            t.start()
-            sess.interim_thread = t
-        else:
-            # Start real interim worker
-            t = threading.Thread(target=_interim_worker, args=(socketio, sid, sess), daemon=True)
-            t.start()
-            sess.interim_thread = t
-
-    @socketio.on("audio_chunk")
-    def on_audio_chunk(payload):
-        sid = request.sid
-        sess = _sessions.get(sid)
-        if not sess:
-            socketio.emit("warn", "chunk received before start; ignoring", to=sid)
-            log("chunk_ignored_no_session", sid=sid)
-            return
-
-        # Two shapes supported:
-        # 1) {chunk: Uint8Array} from client, already binary-packed by socket.io
-        # 2) {audio_data_b64: "..."} older path
-        chunk = None
-        if "chunk" in payload and isinstance(payload["chunk"], (bytes, bytearray)):
-            chunk = payload["chunk"]
-        elif "chunk" in payload and isinstance(payload["chunk"], list):
-            # socket.io sometimes gives list of ints; pack
-            chunk = bytes(payload["chunk"])
-        elif "audio_data_b64" in payload:
-            import base64
-            chunk = base64.b64decode(payload["audio_data_b64"])
-        else:
-            log("chunk_payload_unrecognized", keys=list(payload.keys()))
-            return
-
-        if not chunk:
-            return
-
-        # Append to rolling webm
-        with open(sess.webm_path, "ab") as f:
-            f.write(chunk)
-        sess.bytes_written += len(chunk)
-
-        # Cosmetic progress
-        socketio.emit("msg", f"chunk -> {json.dumps({'size': len(chunk)})}", to=sid)
-
-    @socketio.on("stop")
-    def on_stop():
-        sid = request.sid
-        sess = _sessions.get(sid)
-        if not sess:
-            socketio.emit("warn", "stop without session", to=sid)
-            return
-
-        socketio.emit("msg", "recording stopped", to=sid)
-        log("recording_stopped", sid=sid, session_id=sess.session_id)
-
-        # halt interim thread
-        sess.stop_event.set()
-        if sess.interim_thread and sess.interim_thread.is_alive():
-            sess.interim_thread.join(timeout=1.0)
-
-        # Final transcription
-        final_text = ""
-        try:
-            if DRY_RUN:
-                final_text = "This is a DRY_RUN final transcript that proves the emit path is working."
-            else:
-                if sess.bytes_written > 0:
-                    _ffmpeg_webm_to_wav(sess.webm_path, sess.wav_path)
-                    final_text = _whisper_transcribe_file(sess.wav_path)
-        except Exception as e:
-            log("final_error", error=str(e), session_id=sess.session_id)
-
-        final_text = (final_text or "").strip()
-        if final_text:
-            socketio.emit("final", {"i": int((time.time()-sess.started_at)*1000), "text": final_text}, to=sid)
-            log("final_emitted", chars=len(final_text), session_id=sess.session_id)
-        else:
-            socketio.emit("warn", "No audio or transcription failed.", to=sid)
-
-        # cleanup
-        sess.cleanup()
-        _sessions.pop(sid, None)
-
-    log("routes.websocket loaded; handlers registered")
+    emit("final_transcript", {"text": (final_text or "").strip()})
+    # clear session memory
+    _BUFFERS.pop(session_id, None)
+    _LAST_EMIT_AT.pop(session_id, None)
+    _LAST_INTERIM_TEXT.pop(session_id, None)
+    
--- a/static/js/recording_wiring.js

+++ b/static/js/recording_wiring.js

@@ -2,9 +2,10 @@

 (() => {
   let socket;
   const SESSION_ID = String(Date.now());
-  let stream = null, mediaRecorder = null, starting = false;
+  let stream, mediaRecorder;
   let audioCtx, analyser, dataArray, rafId = null;
 
+  // UI helpers
   const $ = sel => document.querySelector(sel);
   const log = (...a) => {
     const s = a.map(x => (typeof x === "object" ? JSON.stringify(x) : String(x))).join(" ");
@@ -25,21 +26,14 @@

   };
   if (ui.sess) ui.sess.textContent = SESSION_ID;
 
-  function transports() {
-    const force = !!(window.MINA && window.MINA.FORCE_POLLING);
-    return force ? ["polling"] : ["websocket","polling"];
-  }
-
+  // ---- Socket.IO (polling only is fine on Replit)
   function initSocket() {
     if (socket && socket.connected) return;
 
-    const path = (window.MINA && window.MINA.SOCKETIO_PATH) || "/socket.io";
-    const force = !!(window.MINA && window.MINA.FORCE_POLLING);
-
     socket = io(window.location.origin, {
-      path,
-      transports: transports(),
-      upgrade: !force,
+      path: "/socket.io",
+      transports: ["polling"],
+      upgrade: false,
       reconnection: true,
       reconnectionAttempts: 30,
       reconnectionDelay: 500,
@@ -48,19 +42,22 @@

 
     socket.on("connect", () => {
       ui.ws.textContent = "Connected";
-      log("socket connected", { id: socket.id, transport: socket.io.engine.transport.name });
+      log("socket connected id=", socket.id, "transport=", socket.io.engine.transport.name);
       socket.emit("join_session", { session_id: SESSION_ID });
     });
     socket.on("disconnect", (r) => { ui.ws.textContent = "Disconnected"; log("socket disconnected", r); });
     socket.on("connect_error", (e) => { ui.ws.textContent = "Conn error"; log("connect_error", e?.message || e); });
 
     socket.on("server_hello", (m) => log("server_hello", m));
-    socket.on("ack", () => {});
+    socket.on("ack", () => { /* rtt tracking if needed */ });
+
     socket.on("error", (e) => log("socket error", e));
     socket.on("socket_error", (e) => log("transcription error", e));
-    socket.on("debug", (m) => log("DEBUG", m?.message || m));
 
-    socket.on("interim_transcript", (p) => { ui.interim.textContent = p?.text || ""; });
+    socket.on("interim_transcript", (p) => {
+      ui.interim.textContent = p?.text || "";
+    });
+
     socket.on("final_transcript", (p) => {
       const t = (p?.text || "").trim();
       if (!t) return;
@@ -70,6 +67,7 @@

     });
   }
 
+  // ---- Audio meter
   function startMeter() {
     if (!stream) return;
     audioCtx = new (window.AudioContext || window.webkitAudioContext)();
@@ -81,13 +79,14 @@

 
     const tick = () => {
       analyser.getByteTimeDomainData(dataArray);
+      // RMS-like level
       let sum = 0;
       for (let i = 0; i < dataArray.length; i++) {
         const v = (dataArray[i] - 128) / 128;
         sum += v*v;
       }
       const rms = Math.sqrt(sum / dataArray.length);
-      const pct = Math.min(100, Math.max(0, Math.round(rms * 140)));
+      const pct = Math.min(100, Math.max(0, Math.round(rms * 140))); // 0..~140%
       if (ui.meter) ui.meter.style.width = pct + "%";
       rafId = requestAnimationFrame(tick);
     };
@@ -101,74 +100,64 @@

     if (ui.meter) ui.meter.style.width = "0%";
   }
 
+  // ---- Recording
   async function startRecording() {
-    if (starting || (mediaRecorder && mediaRecorder.state === "recording")) return;
-    starting = true;
-
     initSocket();
-    if (!socket || !socket.connected) log("socket not connected yet (will buffer events)");
-
-    try {
-      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
-    } catch (e) {
-      starting = false;
-      ui.mic.textContent = "Mic denied";
-      log("❌ microphone permission denied", e);
-      return;
+    if (!socket || !socket.connected) {
+      log("socket not connected yet");
     }
 
+    // Ask mic
+    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
     ui.mic.textContent = "Recording…";
 
+    // Try webm/opus (widest support); fall back if needed
     let mime = "audio/webm;codecs=opus";
     if (!MediaRecorder.isTypeSupported(mime)) {
       if (MediaRecorder.isTypeSupported("audio/webm")) mime = "audio/webm";
       else if (MediaRecorder.isTypeSupported("audio/ogg;codecs=opus")) mime = "audio/ogg;codecs=opus";
-      else mime = "";
+      else mime = ""; // let browser decide
     }
 
     mediaRecorder = new MediaRecorder(stream, { mimeType: mime, audioBitsPerSecond: 128000 });
 
     mediaRecorder.ondataavailable = async (e) => {
       if (!e.data || e.data.size === 0) return;
-      try {
-        const buf = await e.data.arrayBuffer();
-        const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
-        socket.emit("audio_chunk", {
-          session_id: SESSION_ID,
-          audio_data_b64: b64,
-          mime: e.data.type || mime || "audio/webm",
-          duration_ms: 0
-        });
-        log("chunk ->", { size: e.data.size });
-      } catch (err) {
-        log("chunk encode error", err);
-      }
+      // Convert Blob -> base64
+      const buf = await e.data.arrayBuffer();
+      const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
+      socket.emit("audio_chunk", {
+        session_id: SESSION_ID,
+        audio_data_b64: b64,
+        mime: e.data.type || mime || "audio/webm",
+        duration_ms: 0
+      });
     };
 
     mediaRecorder.onstop = () => {
       stopMeter();
       ui.mic.textContent = "Stopped";
-      socket.emit("finalize_session", {
-        session_id: SESSION_ID,
-        mime: mediaRecorder.mimeType || mime || "audio/webm"
-      });
+      // ask server to finalize (full pass)
+      socket.emit("finalize_session", { session_id: SESSION_ID, mime: mediaRecorder.mimeType || mime || "audio/webm" });
       try { stream.getTracks().forEach(t => t.stop()); } catch {}
       stream = null;
-      log("recording stopped");
-      starting = false;
     };
 
-    mediaRecorder.start(1200); // ~1.2s slices -> matches server cadence
+    // Emit blobs every ~1.2s (balanced latency/cost)
+    mediaRecorder.start(1200);
     startMeter();
-    log("recording started", { mime });
-    starting = false;
   }
 
   function stopRecording() {
-    if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
+    if (mediaRecorder && mediaRecorder.state !== "inactive") {
+      mediaRecorder.stop();
+    }
   }
 
+  // ---- Wire UI
   ui.start?.addEventListener("click", startRecording);
   ui.stop?.addEventListener("click", stopRecording);
+
+  // connect early so join_session is ready before recording
   initSocket();
 })();
--- a/templates/live.html

+++ b/templates/live.html

@@ -0,0 +1,61 @@

+<!-- templates/live.html -->
+<!doctype html>
+<html lang="en">
+<head>
+  <meta charset="utf-8" />
+  <meta
+    name="viewport"
+    content="width=device-width, initial-scale=1, maximum-scale=1"
+  />
+  <title>Mina — Live Transcription</title>
+  <link rel="preconnect" href="https://cdn.socket.io" />
+  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
+  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
+  <style>
+    body { padding: 16px; }
+    .pill { padding: 6px 10px; border-radius: 999px; background: #2a2a2a; color: #ddd; font-size: 0.85rem; }
+    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
+    .meter { height: 10px; background: #1a1a1a; border-radius: 999px; overflow: hidden; }
+    .meter > span { display: block; height: 100%; width: 0%; background: #6aa6ff; transition: width 100ms linear; }
+    .panel { background:#0e0f12; border:1px solid #23252b; border-radius:12px; padding:12px; min-height:140px; color:#dfe6f3;}
+    .panel h5 { margin: 0 0 8px 0; color:#9bb4ff; }
+    pre#debug { font-size: 12px; height: 130px; overflow:auto; background: #0a0b0e; border:1px solid #1e2026; padding:8px; border-radius:8px;}
+    .badge { background:#0b3d1d; color:#bff0c8; padding:3px 8px; border-radius:999px; font-size:12px; }
+    .muted { color:#9aa3ad; }
+    .stack { display:grid; gap:12px; }
+    .grow { flex:1; }
+  </style>
+</head>
+<body>
+  <main class="container">
+    <h2><strong>Mina — Live Transcription</strong></h2>
+
+    <section class="stack">
+      <div class="row">
+        <button id="startRecordingBtn">Start Recording</button>
+        <button id="stopRecordingBtn" class="secondary">Stop</button>
+        <span class="pill" id="wsStatus">Disconnected</span>
+        <span class="pill" id="micStatus">Idle</span>
+        <span class="pill"><span class="muted">Session:</span> <span id="sess"></span></span>
+      </div>
+
+      <div class="meter"><span id="meterFill"></span></div>
+
+      <div class="row">
+        <div class="panel grow">
+          <h5>Interim</h5>
+          <div id="interimText" class="muted"></div>
+        </div>
+        <div class="panel grow">
+          <h5>Final</h5>
+          <div id="finalText"></div>
+        </div>
+      </div>
+
+      <pre id="debug"></pre>
+    </section>
+  </main>
+
+  <script src="/static/js/recording_wiring.js"></script>
+</body>
+</html>