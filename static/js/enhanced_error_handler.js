/**\n * 🚨 ENHANCED ERROR HANDLER: Comprehensive error management and user feedback\n */\n\nclass EnhancedErrorHandler {\n    constructor() {\n        this.errorLog = [];\n        this.maxErrors = 50;\n        this.retryAttempts = new Map();\n        this.maxRetries = 3;\n        \n        this.initializeGlobalErrorHandling();\n        console.log('🚨 Enhanced error handler initialized');\n    }\n    \n    initializeGlobalErrorHandling() {\n        // Catch unhandled promise rejections\n        window.addEventListener('unhandledrejection', (event) => {\n            this.handleError('unhandled_promise', event.reason, {\n                type: 'promise_rejection',\n                promise: event.promise\n            });\n        });\n        \n        // Catch JavaScript errors\n        window.addEventListener('error', (event) => {\n            this.handleError('javascript_error', event.error, {\n                filename: event.filename,\n                lineno: event.lineno,\n                colno: event.colno\n            });\n        });\n        \n        // Override console.error to catch application errors\n        const originalConsoleError = console.error;\n        console.error = (...args) => {\n            this.handleError('console_error', args.join(' '), { args });\n            originalConsoleError.apply(console, args);\n        };\n    }\n    \n    handleError(type, error, context = {}) {\n        const errorInfo = {\n            id: `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            type: type,\n            message: error?.message || error || 'Unknown error',\n            timestamp: new Date().toISOString(),\n            context: context,\n            userAgent: navigator.userAgent,\n            url: window.location.href\n        };\n        \n        // Store error\n        this.errorLog.push(errorInfo);\n        if (this.errorLog.length > this.maxErrors) {\n            this.errorLog.shift();\n        }\n        \n        // Determine error severity and handle accordingly\n        const severity = this.categorizeError(type, error);\n        this.processError(errorInfo, severity);\n    }\n    \n    categorizeError(type, error) {\n        const errorStr = (error?.message || error || '').toLowerCase();\n        \n        // Critical errors that break core functionality\n        if (errorStr.includes('openai') || \n            errorStr.includes('api key') ||\n            errorStr.includes('transcription failed') ||\n            errorStr.includes('audio conversion')) {\n            return 'critical';\n        }\n        \n        // High priority errors affecting user experience\n        if (errorStr.includes('network') ||\n            errorStr.includes('fetch') ||\n            errorStr.includes('timeout') ||\n            errorStr.includes('permission denied')) {\n            return 'high';\n        }\n        \n        // Medium priority errors that are recoverable\n        if (errorStr.includes('chunk') ||\n            errorStr.includes('audio') ||\n            errorStr.includes('interim')) {\n            return 'medium';\n        }\n        \n        // Low priority errors (warnings)\n        return 'low';\n    }\n    \n    processError(errorInfo, severity) {\n        // Log to console with appropriate level\n        const logMethod = severity === 'critical' ? 'error' : \n                         severity === 'high' ? 'warn' : 'info';\n        \n        console[logMethod](`🚨 ${severity.toUpperCase()} ERROR:`, errorInfo);\n        \n        // Show user notification based on severity\n        this.showUserNotification(errorInfo, severity);\n        \n        // Attempt automatic recovery for certain errors\n        this.attemptRecovery(errorInfo, severity);\n        \n        // Send error to monitoring if available\n        this.reportToMonitoring(errorInfo, severity);\n    }\n    \n    showUserNotification(errorInfo, severity) {\n        const messages = {\n            critical: {\n                title: 'Critical Error',\n                text: 'A critical error occurred. Please refresh the page and try again.',\n                type: 'error'\n            },\n            high: {\n                title: 'Connection Issue',\n                text: 'There seems to be a connection problem. Retrying automatically...',\n                type: 'warning'\n            },\n            medium: {\n                title: 'Processing Issue',\n                text: 'A minor issue occurred. The system is attempting to recover.',\n                type: 'info'\n            },\n            low: {\n                title: 'Minor Issue',\n                text: 'A minor issue was detected and logged.',\n                type: 'info'\n            }\n        };\n        \n        const notification = messages[severity];\n        \n        // Use toast system if available\n        if (window.toastSystem) {\n            window.toastSystem[notification.type](notification.text);\n        } else {\n            // Fallback to native notification\n            this.showNativeNotification(notification.title, notification.text, severity);\n        }\n    }\n    \n    showNativeNotification(title, text, severity) {\n        // Create notification element\n        const notification = document.createElement('div');\n        notification.className = `error-notification ${severity}`;\n        notification.innerHTML = `\n            <div class=\"notification-content\">\n                <strong>${title}</strong>\n                <p>${text}</p>\n                <button onclick=\"this.parentElement.parentElement.remove()\">×</button>\n            </div>\n        `;\n        \n        // Add styles if not already present\n        if (!document.getElementById('error-notification-styles')) {\n            const styles = document.createElement('style');\n            styles.id = 'error-notification-styles';\n            styles.textContent = `\n                .error-notification {\n                    position: fixed;\n                    top: 20px;\n                    right: 20px;\n                    max-width: 300px;\n                    padding: 15px;\n                    border-radius: 5px;\n                    background: white;\n                    border: 1px solid #ddd;\n                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n                    z-index: 10001;\n                    animation: slideIn 0.3s ease-out;\n                }\n                .error-notification.critical {\n                    border-left: 4px solid #dc3545;\n                }\n                .error-notification.high {\n                    border-left: 4px solid #fd7e14;\n                }\n                .error-notification.medium {\n                    border-left: 4px solid #ffc107;\n                }\n                .error-notification.low {\n                    border-left: 4px solid #17a2b8;\n                }\n                .notification-content button {\n                    position: absolute;\n                    top: 5px;\n                    right: 10px;\n                    background: none;\n                    border: none;\n                    font-size: 18px;\n                    cursor: pointer;\n                }\n                @keyframes slideIn {\n                    from { transform: translateX(100%); }\n                    to { transform: translateX(0); }\n                }\n            `;\n            document.head.appendChild(styles);\n        }\n        \n        document.body.appendChild(notification);\n        \n        // Auto-remove after delay based on severity\n        const delay = severity === 'critical' ? 10000 : \n                     severity === 'high' ? 7000 : \n                     severity === 'medium' ? 5000 : 3000;\n        \n        setTimeout(() => {\n            if (notification.parentElement) {\n                notification.remove();\n            }\n        }, delay);\n    }\n    \n    attemptRecovery(errorInfo, severity) {\n        const errorType = this.identifyErrorType(errorInfo);\n        \n        switch (errorType) {\n            case 'network_failure':\n                this.handleNetworkFailure(errorInfo);\n                break;\n            case 'api_timeout':\n                this.handleAPITimeout(errorInfo);\n                break;\n            case 'audio_processing_failure':\n                this.handleAudioProcessingFailure(errorInfo);\n                break;\n            case 'permission_denied':\n                this.handlePermissionDenied(errorInfo);\n                break;\n            default:\n                console.log(`ℹ️ No automatic recovery available for error type: ${errorType}`);\n        }\n    }\n    \n    identifyErrorType(errorInfo) {\n        const message = errorInfo.message.toLowerCase();\n        \n        if (message.includes('network') || message.includes('fetch failed')) {\n            return 'network_failure';\n        }\n        if (message.includes('timeout')) {\n            return 'api_timeout';\n        }\n        if (message.includes('audio') || message.includes('conversion')) {\n            return 'audio_processing_failure';\n        }\n        if (message.includes('permission') || message.includes('denied')) {\n            return 'permission_denied';\n        }\n        \n        return 'unknown';\n    }\n    \n    handleNetworkFailure(errorInfo) {\n        console.log('🔄 Attempting network failure recovery...');\n        \n        // Check network connectivity\n        if (navigator.onLine) {\n            // Network is available, might be a temporary API issue\n            setTimeout(() => {\n                console.log('🔄 Retrying after network failure...');\n                // Trigger a test API call or retry last operation\n                this.testAPIConnectivity();\n            }, 2000);\n        } else {\n            // No network connectivity\n            this.showUserNotification({\n                message: 'No internet connection detected. Please check your connection.'\n            }, 'critical');\n        }\n    }\n    \n    handleAPITimeout(errorInfo) {\n        const retryKey = 'api_timeout';\n        const currentRetries = this.retryAttempts.get(retryKey) || 0;\n        \n        if (currentRetries < this.maxRetries) {\n            this.retryAttempts.set(retryKey, currentRetries + 1);\n            \n            const delay = Math.pow(2, currentRetries) * 1000; // Exponential backoff\n            console.log(`🔄 Retrying API call in ${delay}ms (attempt ${currentRetries + 1}/${this.maxRetries})`);\n            \n            setTimeout(() => {\n                // Retry the last operation or test connectivity\n                this.testAPIConnectivity();\n            }, delay);\n        } else {\n            console.warn('❌ Max retries reached for API timeout');\n            this.retryAttempts.delete(retryKey);\n        }\n    }\n    \n    handleAudioProcessingFailure(errorInfo) {\n        console.log('🔄 Attempting audio processing recovery...');\n        \n        // Check if audio permissions are still available\n        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n            navigator.mediaDevices.getUserMedia({ audio: true })\n                .then(() => {\n                    console.log('✅ Audio permissions still available');\n                    // Audio access is fine, might be a processing issue\n                    if (window.professionalRecorder) {\n                        window.professionalRecorder.stopRecording();\n                        setTimeout(() => {\n                            console.log('🔄 Restarting recording after audio processing failure');\n                            // User will need to manually restart\n                        }, 1000);\n                    }\n                })\n                .catch((err) => {\n                    console.error('❌ Audio permissions lost:', err);\n                    this.handlePermissionDenied({ message: 'Audio permission lost' });\n                });\n        }\n    }\n    \n    handlePermissionDenied(errorInfo) {\n        console.log('🚨 Handling permission denied error');\n        \n        this.showUserNotification({\n            message: 'Microphone permission is required for transcription. Please allow access and refresh the page.'\n        }, 'critical');\n    }\n    \n    async testAPIConnectivity() {\n        try {\n            const response = await fetch('/api/transcribe-health', {\n                method: 'GET',\n                timeout: 5000\n            });\n            \n            if (response.ok) {\n                console.log('✅ API connectivity test passed');\n                this.retryAttempts.clear(); // Clear retry counters on success\n            } else {\n                console.warn('⚠️ API connectivity test failed with status:', response.status);\n            }\n        } catch (error) {\n            console.error('❌ API connectivity test failed:', error);\n        }\n    }\n    \n    reportToMonitoring(errorInfo, severity) {\n        // Report to performance monitor if available\n        if (window.performanceMonitor && window.performanceMonitor.recordError) {\n            window.performanceMonitor.recordError(errorInfo, severity);\n        }\n        \n        // Report to pipeline diagnostics if available\n        if (window.pipelineDiagnostics && window.pipelineDiagnostics.addLog) {\n            window.pipelineDiagnostics.addLog('error', {\n                severity,\n                message: errorInfo.message,\n                type: errorInfo.type\n            });\n        }\n    }\n    \n    // Public methods for manual error reporting\n    reportError(message, context = {}) {\n        this.handleError('manual_report', message, context);\n    }\n    \n    getErrorSummary() {\n        const last24Hours = Date.now() - (24 * 60 * 60 * 1000);\n        const recentErrors = this.errorLog.filter(error => \n            new Date(error.timestamp).getTime() > last24Hours\n        );\n        \n        const summary = {\n            total: recentErrors.length,\n            critical: recentErrors.filter(e => this.categorizeError(e.type, e.message) === 'critical').length,\n            high: recentErrors.filter(e => this.categorizeError(e.type, e.message) === 'high').length,\n            medium: recentErrors.filter(e => this.categorizeError(e.type, e.message) === 'medium').length,\n            low: recentErrors.filter(e => this.categorizeError(e.type, e.message) === 'low').length,\n            recentErrors: recentErrors.slice(-10) // Last 10 errors\n        };\n        \n        return summary;\n    }\n    \n    clearErrors() {\n        this.errorLog = [];\n        this.retryAttempts.clear();\n        console.log('🧹 Error log cleared');\n    }\n}\n\n// Initialize global error handler\nwindow.enhancedErrorHandler = new EnhancedErrorHandler();\n\n// Provide global error reporting function\nwindow.reportError = (message, context) => {\n    window.enhancedErrorHandler.reportError(message, context);\n};\n\nconsole.log('✅ Enhanced error handler loaded');"

// [CTO] Defaults to ensure live interim is visible & frequent
window.MINA_FEATURES = Object.assign({
  ENABLE_INTERIM: true,
  SHOW_INTERIM: true,
  REPLACE_INTERIM_ON_FINAL: true,
  INTERIM_THROTTLE_MS: 250,
  RECORDER_TIMESLICE_MS: 250,
}, window.MINA_FEATURES || {});
