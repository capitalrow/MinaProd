/**
 * ðŸ“± MOBILE PERFORMANCE OPTIMIZER
 * Battery-aware processing and touch optimization for mobile devices
 */

class MobilePerformanceOptimizer {
    constructor() {
        this.isMobile = this.detectMobileDevice();
        this.batteryInfo = null;\n        this.performanceLevel = 'balanced'; // 'battery_saver', 'balanced', 'performance'\n        this.touchHandler = null;\n        \n        // Mobile-specific settings\n        this.mobileSettings = {\n            batteryOptimization: true,\n            reducedProcessing: false,\n            adaptiveQuality: true,\n            backgroundProcessing: false,\n            wakeLockEnabled: false\n        };\n        \n        // Performance thresholds for mobile\n        this.mobileThresholds = {\n            lowBattery: 20, // Switch to battery saver mode\n            criticalBattery: 10, // Minimal processing mode\n            thermalThrottle: 0.8, // CPU throttling threshold\n            memoryLimit: 100 * 1024 * 1024 // 100MB memory limit\n        };\n        \n        this.statistics = {\n            batteryOptimizations: 0,\n            performanceModeChanges: 0,\n            touchInteractions: 0,\n            backgroundSaves: 0\n        };\n        \n        if (this.isMobile) {\n            this.initializeMobileOptimizations();\n        }\n        \n        console.log('ðŸ“± Mobile Performance Optimizer initialized', { isMobile: this.isMobile });\n    }\n    \n    /**\n     * Detect if running on mobile device\n     */\n    detectMobileDevice() {\n        const userAgent = navigator.userAgent.toLowerCase();\n        const mobileKeywords = [\n            'android', 'iphone', 'ipad', 'ipod', 'blackberry', \n            'windows phone', 'mobile', 'tablet'\n        ];\n        \n        const isMobileUA = mobileKeywords.some(keyword => userAgent.includes(keyword));\n        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        const isSmallScreen = window.innerWidth <= 768;\n        \n        return isMobileUA || (isTouchDevice && isSmallScreen);\n    }\n    \n    /**\n     * Initialize mobile-specific optimizations\n     */\n    async initializeMobileOptimizations() {\n        // Initialize battery monitoring\n        await this.initializeBatteryMonitoring();\n        \n        // Setup performance monitoring\n        this.setupPerformanceMonitoring();\n        \n        // Initialize touch optimizations\n        this.initializeTouchOptimizations();\n        \n        // Setup background processing optimization\n        this.setupBackgroundOptimization();\n        \n        // Initialize wake lock for recording sessions\n        this.initializeWakeLock();\n        \n        // Setup adaptive quality based on device performance\n        this.setupAdaptiveQuality();\n        \n        console.log('ðŸ“± Mobile optimizations initialized');\n    }\n    \n    /**\n     * Initialize battery monitoring\n     */\n    async initializeBatteryMonitoring() {\n        try {\n            if ('getBattery' in navigator) {\n                this.batteryInfo = await navigator.getBattery();\n                \n                // Listen for battery events\n                this.batteryInfo.addEventListener('levelchange', () => {\n                    this.handleBatteryLevelChange();\n                });\n                \n                this.batteryInfo.addEventListener('chargingchange', () => {\n                    this.handleChargingStateChange();\n                });\n                \n                // Initial battery check\n                this.handleBatteryLevelChange();\n                \n                console.log('ðŸ”‹ Battery monitoring enabled');\n            } else {\n                console.log('ðŸ”‹ Battery API not supported');\n            }\n        } catch (error) {\n            console.log('ðŸ”‹ Battery monitoring not available:', error.message);\n        }\n    }\n    \n    /**\n     * Handle battery level changes\n     */\n    handleBatteryLevelChange() {\n        if (!this.batteryInfo) return;\n        \n        const batteryLevel = this.batteryInfo.level * 100;\n        const isCharging = this.batteryInfo.charging;\n        \n        console.log(`ðŸ”‹ Battery: ${batteryLevel.toFixed(0)}% ${isCharging ? '(charging)' : ''}`);\n        \n        // Adjust performance based on battery level\n        if (!isCharging) {\n            if (batteryLevel <= this.mobileThresholds.criticalBattery) {\n                this.setPerformanceLevel('battery_saver');\n                this.enableAggressiveBatteryOptimization();\n            } else if (batteryLevel <= this.mobileThresholds.lowBattery) {\n                this.setPerformanceLevel('battery_saver');\n                this.enableBatteryOptimization();\n            } else if (batteryLevel > this.mobileThresholds.lowBattery + 10) {\n                // Hysteresis to avoid frequent mode switching\n                this.setPerformanceLevel('balanced');\n                this.disableBatteryOptimization();\n            }\n        } else {\n            // Device is charging, can use higher performance\n            this.setPerformanceLevel('performance');\n            this.disableBatteryOptimization();\n        }\n        \n        // Emit battery status event\n        window.dispatchEvent(new CustomEvent('batteryStatusUpdate', {\n            detail: {\n                level: batteryLevel,\n                charging: isCharging,\n                performanceLevel: this.performanceLevel\n            }\n        }));\n    }\n    \n    /**\n     * Handle charging state changes\n     */\n    handleChargingStateChange() {\n        if (!this.batteryInfo) return;\n        \n        this.handleBatteryLevelChange(); // Re-evaluate performance level\n    }\n    \n    /**\n     * Set performance level\n     */\n    setPerformanceLevel(level) {\n        if (this.performanceLevel === level) return;\n        \n        this.performanceLevel = level;\n        this.statistics.performanceModeChanges++;\n        \n        console.log(`ðŸ“± Performance level changed to: ${level}`);\n        \n        // Apply performance-specific optimizations\n        switch (level) {\n            case 'battery_saver':\n                this.applyBatterySaverOptimizations();\n                break;\n            case 'balanced':\n                this.applyBalancedOptimizations();\n                break;\n            case 'performance':\n                this.applyPerformanceOptimizations();\n                break;\n        }\n        \n        // Emit performance level change event\n        window.dispatchEvent(new CustomEvent('performanceLevelChanged', {\n            detail: { level: level }\n        }));\n    }\n    \n    /**\n     * Apply battery saver optimizations\n     */\n    applyBatterySaverOptimizations() {\n        // Reduce processing frequency\n        if (window.vadOptimization) {\n            window.vadOptimization.configure({\n                silenceThreshold: 0.02, // Higher threshold = less processing\n                minSpeechDuration: 500, // Longer minimum speech\n                maxSilenceDuration: 2000 // Longer silence tolerance\n            });\n        }\n        \n        // Increase chunk sizes to reduce API calls\n        if (window.adaptiveChunking) {\n            window.adaptiveChunking.configure({\n                minChunkSize: 1500,\n                maxChunkSize: 4000,\n                baseChunkSize: 2000\n            });\n        }\n        \n        // Reduce UI update frequency\n        this.setUIUpdateFrequency(2000); // 2 seconds\n        \n        console.log('ðŸ”‹ Battery saver optimizations applied');\n    }\n    \n    /**\n     * Apply balanced optimizations\n     */\n    applyBalancedOptimizations() {\n        // Standard settings\n        if (window.vadOptimization) {\n            window.vadOptimization.configure({\n                silenceThreshold: 0.01,\n                minSpeechDuration: 300,\n                maxSilenceDuration: 1500\n            });\n        }\n        \n        if (window.adaptiveChunking) {\n            window.adaptiveChunking.configure({\n                minChunkSize: 1000,\n                maxChunkSize: 3000,\n                baseChunkSize: 1500\n            });\n        }\n        \n        this.setUIUpdateFrequency(1000); // 1 second\n        \n        console.log('âš–ï¸ Balanced optimizations applied');\n    }\n    \n    /**\n     * Apply performance optimizations\n     */\n    applyPerformanceOptimizations() {\n        // High performance settings\n        if (window.vadOptimization) {\n            window.vadOptimization.configure({\n                silenceThreshold: 0.005,\n                minSpeechDuration: 200,\n                maxSilenceDuration: 1000\n            });\n        }\n        \n        if (window.adaptiveChunking) {\n            window.adaptiveChunking.configure({\n                minChunkSize: 500,\n                maxChunkSize: 2000,\n                baseChunkSize: 1000\n            });\n        }\n        \n        this.setUIUpdateFrequency(500); // 0.5 seconds\n        \n        console.log('ðŸš€ Performance optimizations applied');\n    }\n    \n    /**\n     * Enable battery optimization\n     */\n    enableBatteryOptimization() {\n        this.mobileSettings.batteryOptimization = true;\n        this.mobileSettings.reducedProcessing = true;\n        this.statistics.batteryOptimizations++;\n        \n        // Reduce background processing\n        this.mobileSettings.backgroundProcessing = false;\n        \n        console.log('ðŸ”‹ Battery optimization enabled');\n    }\n    \n    /**\n     * Enable aggressive battery optimization\n     */\n    enableAggressiveBatteryOptimization() {\n        this.enableBatteryOptimization();\n        \n        // Additional aggressive optimizations\n        this.mobileSettings.adaptiveQuality = false;\n        \n        // Disable non-essential features\n        this.disableNonEssentialFeatures();\n        \n        console.log('ðŸ”‹ Aggressive battery optimization enabled');\n    }\n    \n    /**\n     * Disable battery optimization\n     */\n    disableBatteryOptimization() {\n        this.mobileSettings.batteryOptimization = false;\n        this.mobileSettings.reducedProcessing = false;\n        this.mobileSettings.adaptiveQuality = true;\n        \n        // Re-enable features\n        this.enableAllFeatures();\n        \n        console.log('ðŸ”‹ Battery optimization disabled');\n    }\n    \n    /**\n     * Setup performance monitoring\n     */\n    setupPerformanceMonitoring() {\n        // Monitor memory usage\n        setInterval(() => {\n            if (performance.memory) {\n                const memoryUsage = performance.memory.usedJSHeapSize;\n                if (memoryUsage > this.mobileThresholds.memoryLimit) {\n                    this.handleHighMemoryUsage();\n                }\n            }\n        }, 10000); // Check every 10 seconds\n        \n        // Monitor device orientation\n        window.addEventListener('orientationchange', () => {\n            this.handleOrientationChange();\n        });\n        \n        console.log('ðŸ“Š Mobile performance monitoring setup');\n    }\n    \n    /**\n     * Handle high memory usage\n     */\n    handleHighMemoryUsage() {\n        console.log('âš ï¸ High memory usage detected, optimizing...');\n        \n        // Force garbage collection if available\n        if (window.gc) {\n            window.gc();\n        }\n        \n        // Clear unnecessary buffers\n        this.clearBuffers();\n        \n        // Reduce quality if needed\n        if (this.mobileSettings.adaptiveQuality) {\n            this.reduceQualityTemporarily();\n        }\n    }\n    \n    /**\n     * Initialize touch optimizations\n     */\n    initializeTouchOptimizations() {\n        this.touchHandler = {\n            touches: new Map(),\n            gestures: {\n                swipe: null,\n                pinch: null,\n                tap: null\n            }\n        };\n        \n        // Optimize touch event handling\n        const touchOptions = { passive: true };\n        \n        document.addEventListener('touchstart', (e) => {\n            this.handleTouchStart(e);\n        }, touchOptions);\n        \n        document.addEventListener('touchmove', (e) => {\n            this.handleTouchMove(e);\n        }, touchOptions);\n        \n        document.addEventListener('touchend', (e) => {\n            this.handleTouchEnd(e);\n        }, touchOptions);\n        \n        // Add touch feedback for buttons\n        this.addTouchFeedback();\n        \n        console.log('ðŸ‘† Touch optimizations initialized');\n    }\n    \n    /**\n     * Handle touch start\n     */\n    handleTouchStart(event) {\n        this.statistics.touchInteractions++;\n        \n        // Track touches for gesture recognition\n        for (const touch of event.changedTouches) {\n            this.touchHandler.touches.set(touch.identifier, {\n                startX: touch.clientX,\n                startY: touch.clientY,\n                startTime: Date.now()\n            });\n        }\n    }\n    \n    /**\n     * Handle touch move\n     */\n    handleTouchMove(event) {\n        // Detect gestures\n        this.detectGestures(event);\n    }\n    \n    /**\n     * Handle touch end\n     */\n    handleTouchEnd(event) {\n        // Process completed touches\n        for (const touch of event.changedTouches) {\n            const touchData = this.touchHandler.touches.get(touch.identifier);\n            if (touchData) {\n                this.processTouchGesture(touch, touchData);\n                this.touchHandler.touches.delete(touch.identifier);\n            }\n        }\n    }\n    \n    /**\n     * Detect gestures from touch events\n     */\n    detectGestures(event) {\n        if (event.touches.length === 1) {\n            // Single touch - possible swipe\n            const touch = event.touches[0];\n            const touchData = this.touchHandler.touches.get(touch.identifier);\n            \n            if (touchData) {\n                const deltaX = touch.clientX - touchData.startX;\n                const deltaY = touch.clientY - touchData.startY;\n                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n                \n                if (distance > 50) { // Minimum swipe distance\n                    const direction = this.getSwipeDirection(deltaX, deltaY);\n                    this.emitGestureEvent('swipe', direction);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Get swipe direction\n     */\n    getSwipeDirection(deltaX, deltaY) {\n        const absDeltaX = Math.abs(deltaX);\n        const absDeltaY = Math.abs(deltaY);\n        \n        if (absDeltaX > absDeltaY) {\n            return deltaX > 0 ? 'right' : 'left';\n        } else {\n            return deltaY > 0 ? 'down' : 'up';\n        }\n    }\n    \n    /**\n     * Process touch gesture\n     */\n    processTouchGesture(touch, touchData) {\n        const duration = Date.now() - touchData.startTime;\n        const deltaX = touch.clientX - touchData.startX;\n        const deltaY = touch.clientY - touchData.startY;\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        \n        if (duration < 300 && distance < 10) {\n            // Quick tap\n            this.emitGestureEvent('tap', 'quick');\n        } else if (duration > 1000 && distance < 10) {\n            // Long press\n            this.emitGestureEvent('longpress', 'hold');\n        }\n    }\n    \n    /**\n     * Emit gesture event\n     */\n    emitGestureEvent(type, direction) {\n        console.log(`ðŸŽ† Gesture detected: ${type} ${direction}`);\n        \n        window.dispatchEvent(new CustomEvent('mobileGesture', {\n            detail: { type, direction }\n        }));\n    }\n    \n    /**\n     * Add touch feedback to interactive elements\n     */\n    addTouchFeedback() {\n        const style = document.createElement('style');\n        style.textContent = `\n            .touch-feedback {\n                transition: all 0.1s ease;\n            }\n            \n            .touch-feedback:active {\n                transform: scale(0.95);\n                opacity: 0.8;\n            }\n            \n            button, .btn, .record-button {\n                touch-action: manipulation;\n                user-select: none;\n                -webkit-tap-highlight-color: transparent;\n            }\n        `;\n        \n        document.head.appendChild(style);\n        \n        // Add touch feedback class to interactive elements\n        const interactiveElements = document.querySelectorAll('button, .btn, .record-button');\n        interactiveElements.forEach(element => {\n            element.classList.add('touch-feedback');\n        });\n    }\n    \n    /**\n     * Initialize wake lock for recording sessions\n     */\n    async initializeWakeLock() {\n        try {\n            if ('wakeLock' in navigator) {\n                console.log('ðŸ“± Wake lock API available');\n                \n                // Listen for recording events to manage wake lock\n                window.addEventListener('recordingStarted', async () => {\n                    await this.requestWakeLock();\n                });\n                \n                window.addEventListener('recordingStopped', () => {\n                    this.releaseWakeLock();\n                });\n            }\n        } catch (error) {\n            console.log('ðŸ“± Wake lock not available:', error.message);\n        }\n    }\n    \n    /**\n     * Request wake lock to prevent screen from turning off\n     */\n    async requestWakeLock() {\n        try {\n            if ('wakeLock' in navigator && !this.mobileSettings.wakeLockEnabled) {\n                const wakeLock = await navigator.wakeLock.request('screen');\n                this.mobileSettings.wakeLockEnabled = true;\n                \n                wakeLock.addEventListener('release', () => {\n                    this.mobileSettings.wakeLockEnabled = false;\n                    console.log('ðŸ“± Wake lock released');\n                });\n                \n                console.log('ðŸ“± Wake lock acquired');\n            }\n        } catch (error) {\n            console.log('ðŸ“± Failed to acquire wake lock:', error.message);\n        }\n    }\n    \n    /**\n     * Release wake lock\n     */\n    releaseWakeLock() {\n        if (this.mobileSettings.wakeLockEnabled) {\n            // Wake lock will be automatically released when page becomes hidden\n            this.mobileSettings.wakeLockEnabled = false;\n            console.log('ðŸ“± Wake lock released');\n        }\n    }\n    \n    /**\n     * Setup adaptive quality based on device performance\n     */\n    setupAdaptiveQuality() {\n        // Monitor frame rate and adjust quality\n        let frameCount = 0;\n        let lastTime = performance.now();\n        \n        const measureFrameRate = () => {\n            const currentTime = performance.now();\n            frameCount++;\n            \n            if (currentTime - lastTime >= 1000) { // Every second\n                const fps = frameCount;\n                frameCount = 0;\n                lastTime = currentTime;\n                \n                this.adjustQualityBasedOnPerformance(fps);\n            }\n            \n            requestAnimationFrame(measureFrameRate);\n        };\n        \n        requestAnimationFrame(measureFrameRate);\n    }\n    \n    /**\n     * Adjust quality based on device performance\n     */\n    adjustQualityBasedOnPerformance(fps) {\n        if (!this.mobileSettings.adaptiveQuality) return;\n        \n        if (fps < 30 && this.performanceLevel !== 'battery_saver') {\n            console.log('ðŸ“± Low FPS detected, reducing quality');\n            this.reduceQualityTemporarily();\n        } else if (fps > 50 && this.performanceLevel === 'performance') {\n            console.log('ðŸ“± Good FPS, maintaining quality');\n        }\n    }\n    \n    /**\n     * Utility methods\n     */\n    setUIUpdateFrequency(intervalMs) {\n        // Update UI update intervals for various components\n        window.dispatchEvent(new CustomEvent('updateUIFrequency', {\n            detail: { interval: intervalMs }\n        }));\n    }\n    \n    handleOrientationChange() {\n        // Delay to allow for layout changes\n        setTimeout(() => {\n            console.log('ðŸ“± Orientation changed, optimizing layout');\n            window.dispatchEvent(new CustomEvent('orientationOptimize'));\n        }, 100);\n    }\n    \n    clearBuffers() {\n        // Clear audio and transcript buffers if available\n        if (window.vadOptimization) {\n            window.vadOptimization.reset();\n        }\n        if (window.adaptiveChunking) {\n            window.adaptiveChunking.reset();\n        }\n    }\n    \n    reduceQualityTemporarily() {\n        // Temporarily reduce processing quality\n        console.log('ðŸ“± Temporarily reducing quality for performance');\n        \n        window.dispatchEvent(new CustomEvent('reduceQuality', {\n            detail: { temporary: true, duration: 30000 } // 30 seconds\n        }));\n    }\n    \n    disableNonEssentialFeatures() {\n        console.log('ðŸ“± Disabling non-essential features for battery saving');\n        \n        // Disable visual effects, animations, etc.\n        window.dispatchEvent(new CustomEvent('disableNonEssential'));\n    }\n    \n    enableAllFeatures() {\n        console.log('ðŸ“± Re-enabling all features');\n        \n        window.dispatchEvent(new CustomEvent('enableAllFeatures'));\n    }\n    \n    /**\n     * Get mobile optimization statistics\n     */\n    getStatistics() {\n        const batteryLevel = this.batteryInfo ? this.batteryInfo.level * 100 : null;\n        const isCharging = this.batteryInfo ? this.batteryInfo.charging : null;\n        \n        return {\n            ...this.statistics,\n            isMobile: this.isMobile,\n            performanceLevel: this.performanceLevel,\n            batteryLevel: batteryLevel,\n            isCharging: isCharging,\n            mobileSettings: { ...this.mobileSettings },\n            memoryUsage: performance.memory ? performance.memory.usedJSHeapSize : null\n        };\n    }\n}\n\n// Initialize global mobile optimizer\nwindow.mobileOptimizer = new MobilePerformanceOptimizer();\n\nconsole.log('âœ… Mobile Performance Optimizer loaded');"