/**\n * 🎯 AUDIO QUALITY ASSURANCE: Comparative analysis of audio vs transcript quality\n */\n\nclass AudioQualityAssurance {\n    constructor() {\n        this.sessions = new Map();\n        this.qualityMetrics = {\n            wer: 0,           // Word Error Rate\n            accuracy: 0,      // Overall accuracy\n            latency: 0,       // Average latency\n            drift: 0,         // Semantic drift\n            confidence: 0,    // Average confidence\n            completeness: 0   // Transcription completeness\n        };\n        \n        this.thresholds = {\n            wer_target: 0.10,          // Target: ≤10% WER\n            latency_target: 500,       // Target: <500ms latency\n            accuracy_target: 0.95,     // Target: ≥95% accuracy\n            confidence_target: 0.90,   // Target: ≥90% confidence\n            drift_target: 0.05         // Target: <5% semantic drift\n        };\n        \n        this.initializeQualityTracking();\n        console.log('🎯 Audio Quality Assurance initialized');\n    }\n    \n    initializeQualityTracking() {\n        // Listen for transcription events\n        window.addEventListener('transcriptionComplete', (event) => {\n            this.analyzeTranscriptionQuality(event.detail);\n        });\n        \n        // Listen for audio chunk events\n        window.addEventListener('audioChunkCollected', (event) => {\n            this.trackAudioChunk(event.detail);\n        });\n        \n        // Listen for session events\n        window.addEventListener('sessionStarted', (event) => {\n            this.startQualitySession(event.detail.sessionId);\n        });\n    }\n    \n    startQualitySession(sessionId) {\n        this.sessions.set(sessionId, {\n            id: sessionId,\n            startTime: Date.now(),\n            audioChunks: [],\n            transcriptSegments: [],\n            qualityScores: [],\n            performanceMetrics: {\n                totalLatency: 0,\n                totalWords: 0,\n                totalConfidence: 0,\n                processingTimes: [],\n                errorCount: 0\n            }\n        });\n        \n        console.log(`🎯 QA session started: ${sessionId}`);\n    }\n    \n    trackAudioChunk(chunkData) {\n        const currentSession = this.getCurrentSession();\n        if (!currentSession) return;\n        \n        currentSession.audioChunks.push({\n            timestamp: Date.now(),\n            size: chunkData.size || 0,\n            duration: chunkData.duration || 1000,\n            chunkId: chunkData.chunkId || currentSession.audioChunks.length\n        });\n        \n        // Calculate audio quality metrics\n        this.calculateAudioQualityMetrics(currentSession);\n    }\n    \n    analyzeTranscriptionQuality(transcriptionData) {\n        const currentSession = this.getCurrentSession();\n        if (!currentSession) return;\n        \n        const segment = {\n            timestamp: Date.now(),\n            text: transcriptionData.text || '',\n            confidence: transcriptionData.confidence || 0,\n            processingTime: transcriptionData.processingTime || 0,\n            isInterim: transcriptionData.isInterim || false,\n            chunkId: transcriptionData.chunkIndex || 0\n        };\n        \n        currentSession.transcriptSegments.push(segment);\n        \n        // Update performance metrics\n        const metrics = currentSession.performanceMetrics;\n        metrics.totalWords += segment.text.split(' ').length;\n        metrics.totalConfidence += segment.confidence;\n        metrics.totalLatency += segment.processingTime;\n        metrics.processingTimes.push(segment.processingTime);\n        \n        // Calculate quality scores\n        this.calculateQualityScores(currentSession, segment);\n        \n        // Update real-time quality dashboard\n        this.updateQualityDashboard(currentSession);\n        \n        console.log(`🎯 QA Analysis:`, {\n            text: segment.text.substring(0, 30) + '...',\n            confidence: Math.round(segment.confidence * 100) + '%',\n            latency: Math.round(segment.processingTime) + 'ms'\n        });\n    }\n    \n    calculateQualityScores(session, segment) {\n        const metrics = session.performanceMetrics;\n        const segmentCount = session.transcriptSegments.length;\n        \n        if (segmentCount === 0) return;\n        \n        // Calculate average confidence\n        this.qualityMetrics.confidence = metrics.totalConfidence / segmentCount;\n        \n        // Calculate average latency\n        this.qualityMetrics.latency = metrics.totalLatency / segmentCount;\n        \n        // Calculate accuracy based on confidence and consistency\n        this.qualityMetrics.accuracy = this.calculateAccuracy(session);\n        \n        // Calculate Word Error Rate estimation\n        this.qualityMetrics.wer = this.estimateWER(session);\n        \n        // Calculate semantic drift\n        this.qualityMetrics.drift = this.calculateSemanticDrift(session);\n        \n        // Calculate completeness\n        this.qualityMetrics.completeness = this.calculateCompleteness(session);\n        \n        // Generate quality score (0-100)\n        const qualityScore = this.generateOverallQualityScore();\n        \n        session.qualityScores.push({\n            timestamp: Date.now(),\n            overall: qualityScore,\n            metrics: { ...this.qualityMetrics }\n        });\n    }\n    \n    calculateAccuracy(session) {\n        const segments = session.transcriptSegments;\n        if (segments.length === 0) return 0;\n        \n        // Weight accuracy by confidence and consistency\n        let weightedAccuracy = 0;\n        let totalWeight = 0;\n        \n        for (let i = 0; i < segments.length; i++) {\n            const segment = segments[i];\n            const weight = segment.confidence * (segment.text.length / 100); // Weight by confidence and length\n            \n            weightedAccuracy += segment.confidence * weight;\n            totalWeight += weight;\n        }\n        \n        return totalWeight > 0 ? weightedAccuracy / totalWeight : 0;\n    }\n    \n    estimateWER(session) {\n        const segments = session.transcriptSegments;\n        if (segments.length < 2) return 0;\n        \n        // Estimate WER based on confidence drops and consistency\n        let errorIndicators = 0;\n        let totalComparisons = 0;\n        \n        for (let i = 1; i < segments.length; i++) {\n            const current = segments[i];\n            const previous = segments[i - 1];\n            \n            // Low confidence indicates potential errors\n            if (current.confidence < 0.7) errorIndicators++;\n            \n            // Large processing time indicates difficulty\n            if (current.processingTime > this.thresholds.latency_target * 2) errorIndicators++;\n            \n            // Check for repeated content (possible error/retry)\n            if (this.calculateTextSimilarity(current.text, previous.text) > 0.8) {\n                errorIndicators++;\n            }\n            \n            totalComparisons += 3; // Three checks per comparison\n        }\n        \n        return totalComparisons > 0 ? errorIndicators / totalComparisons : 0;\n    }\n    \n    calculateSemanticDrift(session) {\n        const segments = session.transcriptSegments;\n        if (segments.length < 3) return 0;\n        \n        // Calculate semantic consistency across segments\n        let driftScore = 0;\n        let comparisons = 0;\n        \n        // Compare every 3rd segment to detect topic drift\n        for (let i = 2; i < segments.length; i += 3) {\n            const current = segments[i].text;\n            const previous = segments[i - 2].text;\n            \n            const similarity = this.calculateSemanticSimilarity(current, previous);\n            if (similarity < 0.3) driftScore++; // Significant topic change\n            \n            comparisons++;\n        }\n        \n        return comparisons > 0 ? driftScore / comparisons : 0;\n    }\n    \n    calculateCompleteness(session) {\n        const audioChunks = session.audioChunks.length;\n        const transcriptSegments = session.transcriptSegments.filter(s => s.text.trim().length > 0).length;\n        \n        if (audioChunks === 0) return 0;\n        \n        // Calculate how many audio chunks resulted in meaningful transcription\n        const completeness = transcriptSegments / audioChunks;\n        return Math.min(1.0, completeness); // Cap at 100%\n    }\n    \n    calculateTextSimilarity(text1, text2) {\n        if (!text1 || !text2) return 0;\n        \n        const words1 = text1.toLowerCase().split(' ');\n        const words2 = text2.toLowerCase().split(' ');\n        \n        const commonWords = words1.filter(word => words2.includes(word));\n        const totalWords = Math.max(words1.length, words2.length);\n        \n        return totalWords > 0 ? commonWords.length / totalWords : 0;\n    }\n    \n    calculateSemanticSimilarity(text1, text2) {\n        // Simple semantic similarity based on common words and phrases\n        if (!text1 || !text2) return 0;\n        \n        const sentences1 = text1.toLowerCase().split(/[.!?]/);\n        const sentences2 = text2.toLowerCase().split(/[.!?]/);\n        \n        let totalSimilarity = 0;\n        let comparisons = 0;\n        \n        for (const sentence1 of sentences1) {\n            for (const sentence2 of sentences2) {\n                totalSimilarity += this.calculateTextSimilarity(sentence1, sentence2);\n                comparisons++;\n            }\n        }\n        \n        return comparisons > 0 ? totalSimilarity / comparisons : 0;\n    }\n    \n    generateOverallQualityScore() {\n        const weights = {\n            accuracy: 0.3,      // 30% weight\n            confidence: 0.25,   // 25% weight\n            latency: 0.2,       // 20% weight\n            completeness: 0.15, // 15% weight\n            wer: -0.1           // 10% penalty for errors\n        };\n        \n        // Normalize latency (lower is better)\n        const normalizedLatency = Math.max(0, 1 - (this.qualityMetrics.latency / (this.thresholds.latency_target * 2)));\n        \n        // Calculate weighted score\n        const score = (\n            this.qualityMetrics.accuracy * weights.accuracy +\n            this.qualityMetrics.confidence * weights.confidence +\n            normalizedLatency * weights.latency +\n            this.qualityMetrics.completeness * weights.completeness +\n            (1 - this.qualityMetrics.wer) * Math.abs(weights.wer)\n        ) * 100;\n        \n        return Math.round(Math.max(0, Math.min(100, score)));\n    }\n    \n    calculateAudioQualityMetrics(session) {\n        const chunks = session.audioChunks;\n        if (chunks.length === 0) return;\n        \n        // Calculate audio continuity\n        let continuityScore = 1.0;\n        for (let i = 1; i < chunks.length; i++) {\n            const gap = chunks[i].timestamp - (chunks[i-1].timestamp + chunks[i-1].duration);\n            if (gap > 2000) { // More than 2 second gap\n                continuityScore -= 0.1;\n            }\n        }\n        \n        session.audioQuality = {\n            continuity: Math.max(0, continuityScore),\n            averageChunkSize: chunks.reduce((sum, chunk) => sum + chunk.size, 0) / chunks.length,\n            totalDuration: chunks.reduce((sum, chunk) => sum + chunk.duration, 0)\n        };\n    }\n    \n    updateQualityDashboard(session) {\n        const dashboard = this.getQualityDashboard();\n        if (!dashboard) return;\n        \n        const overallScore = this.generateOverallQualityScore();\n        const meetsTargets = this.checkQualityTargets();\n        \n        dashboard.innerHTML = `\n            <div class=\"quality-dashboard\">\n                <h4>🎯 Quality Assurance Dashboard</h4>\n                \n                <div class=\"quality-score\">\n                    <div class=\"score-circle ${this.getScoreClass(overallScore)}\">\n                        <span class=\"score-value\">${overallScore}</span>\n                        <span class=\"score-label\">Quality Score</span>\n                    </div>\n                </div>\n                \n                <div class=\"quality-metrics\">\n                    <div class=\"metric-row\">\n                        <span class=\"metric-label\">Accuracy:</span>\n                        <span class=\"metric-value ${this.getMetricClass(this.qualityMetrics.accuracy, 0.95)}\">\n                            ${Math.round(this.qualityMetrics.accuracy * 100)}%\n                        </span>\n                        <span class=\"target\">Target: ≥95%</span>\n                    </div>\n                    \n                    <div class=\"metric-row\">\n                        <span class=\"metric-label\">Latency:</span>\n                        <span class=\"metric-value ${this.getMetricClass(this.thresholds.latency_target, this.qualityMetrics.latency, true)}\">\n                            ${Math.round(this.qualityMetrics.latency)}ms\n                        </span>\n                        <span class=\"target\">Target: <500ms</span>\n                    </div>\n                    \n                    <div class=\"metric-row\">\n                        <span class=\"metric-label\">WER:</span>\n                        <span class=\"metric-value ${this.getMetricClass(this.thresholds.wer_target, this.qualityMetrics.wer, true)}\">\n                            ${Math.round(this.qualityMetrics.wer * 100)}%\n                        </span>\n                        <span class=\"target\">Target: ≤10%</span>\n                    </div>\n                    \n                    <div class=\"metric-row\">\n                        <span class=\"metric-label\">Confidence:</span>\n                        <span class=\"metric-value ${this.getMetricClass(this.qualityMetrics.confidence, 0.90)}\">\n                            ${Math.round(this.qualityMetrics.confidence * 100)}%\n                        </span>\n                        <span class=\"target\">Target: ≥90%</span>\n                    </div>\n                    \n                    <div class=\"metric-row\">\n                        <span class=\"metric-label\">Completeness:</span>\n                        <span class=\"metric-value ${this.getMetricClass(this.qualityMetrics.completeness, 0.95)}\">\n                            ${Math.round(this.qualityMetrics.completeness * 100)}%\n                        </span>\n                        <span class=\"target\">Target: ≥95%</span>\n                    </div>\n                </div>\n                \n                <div class=\"quality-status\">\n                    <div class=\"status-indicator ${meetsTargets.overall ? 'pass' : 'fail'}\">\n                        ${meetsTargets.overall ? '✅ Meets Industry Standards' : '⚠️ Below Target Performance'}\n                    </div>\n                </div>\n                \n                <div class=\"session-stats\">\n                    <small>\n                        Session: ${session.id.substring(0, 8)}... | \n                        Segments: ${session.transcriptSegments.length} | \n                        Words: ${session.performanceMetrics.totalWords}\n                    </small>\n                </div>\n            </div>\n        `;\n    }\n    \n    getQualityDashboard() {\n        let dashboard = document.getElementById('quality-dashboard');\n        if (!dashboard) {\n            dashboard = document.createElement('div');\n            dashboard.id = 'quality-dashboard';\n            dashboard.style.cssText = `\n                position: fixed;\n                bottom: 10px;\n                right: 10px;\n                width: 350px;\n                background: rgba(0, 0, 0, 0.9);\n                color: white;\n                padding: 15px;\n                border-radius: 8px;\n                font-family: monospace;\n                font-size: 11px;\n                z-index: 9999;\n                box-shadow: 0 4px 8px rgba(0,0,0,0.3);\n            `;\n            \n            // Add QA dashboard styles\n            this.addQualityDashboardStyles();\n            document.body.appendChild(dashboard);\n        }\n        return dashboard;\n    }\n    \n    addQualityDashboardStyles() {\n        if (document.getElementById('qa-dashboard-styles')) return;\n        \n        const styles = document.createElement('style');\n        styles.id = 'qa-dashboard-styles';\n        styles.textContent = `\n            .quality-dashboard h4 {\n                margin: 0 0 10px 0;\n                color: #ffd700;\n            }\n            \n            .quality-score {\n                text-align: center;\n                margin: 10px 0;\n            }\n            \n            .score-circle {\n                display: inline-block;\n                width: 80px;\n                height: 80px;\n                border-radius: 50%;\n                border: 3px solid;\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                justify-content: center;\n            }\n            \n            .score-circle.excellent { border-color: #28a745; }\n            .score-circle.good { border-color: #ffc107; }\n            .score-circle.poor { border-color: #dc3545; }\n            \n            .score-value {\n                font-size: 24px;\n                font-weight: bold;\n            }\n            \n            .score-label {\n                font-size: 8px;\n                opacity: 0.8;\n            }\n            \n            .quality-metrics {\n                margin: 15px 0;\n            }\n            \n            .metric-row {\n                display: flex;\n                justify-content: space-between;\n                margin: 5px 0;\n                padding: 3px 0;\n                border-bottom: 1px solid rgba(255,255,255,0.1);\n            }\n            \n            .metric-label {\n                flex: 1;\n            }\n            \n            .metric-value {\n                font-weight: bold;\n                min-width: 50px;\n                text-align: center;\n            }\n            \n            .metric-value.pass { color: #28a745; }\n            .metric-value.warning { color: #ffc107; }\n            .metric-value.fail { color: #dc3545; }\n            \n            .target {\n                font-size: 9px;\n                opacity: 0.6;\n                min-width: 80px;\n            }\n            \n            .quality-status {\n                margin: 10px 0;\n                text-align: center;\n            }\n            \n            .status-indicator {\n                padding: 5px 10px;\n                border-radius: 4px;\n                font-size: 10px;\n            }\n            \n            .status-indicator.pass {\n                background: rgba(40, 167, 69, 0.3);\n                border: 1px solid #28a745;\n            }\n            \n            .status-indicator.fail {\n                background: rgba(220, 53, 69, 0.3);\n                border: 1px solid #dc3545;\n            }\n            \n            .session-stats {\n                border-top: 1px solid rgba(255,255,255,0.1);\n                padding-top: 5px;\n                text-align: center;\n                opacity: 0.7;\n            }\n        `;\n        \n        document.head.appendChild(styles);\n    }\n    \n    getScoreClass(score) {\n        if (score >= 85) return 'excellent';\n        if (score >= 70) return 'good';\n        return 'poor';\n    }\n    \n    getMetricClass(value, target, isLowerBetter = false) {\n        const meetsTarget = isLowerBetter ? value <= target : value >= target;\n        const isClose = isLowerBetter ? value <= target * 1.2 : value >= target * 0.8;\n        \n        if (meetsTarget) return 'pass';\n        if (isClose) return 'warning';\n        return 'fail';\n    }\n    \n    checkQualityTargets() {\n        return {\n            accuracy: this.qualityMetrics.accuracy >= this.thresholds.accuracy_target,\n            latency: this.qualityMetrics.latency <= this.thresholds.latency_target,\n            wer: this.qualityMetrics.wer <= this.thresholds.wer_target,\n            confidence: this.qualityMetrics.confidence >= this.thresholds.confidence_target,\n            drift: this.qualityMetrics.drift <= this.thresholds.drift_target,\n            overall: (\n                this.qualityMetrics.accuracy >= this.thresholds.accuracy_target &&\n                this.qualityMetrics.latency <= this.thresholds.latency_target &&\n                this.qualityMetrics.wer <= this.thresholds.wer_target\n            )\n        };\n    }\n    \n    getCurrentSession() {\n        // Get the most recent session\n        const sessions = Array.from(this.sessions.values());\n        return sessions.length > 0 ? sessions[sessions.length - 1] : null;\n    }\n    \n    generateQualityReport() {\n        const session = this.getCurrentSession();\n        if (!session) return null;\n        \n        const report = {\n            sessionId: session.id,\n            timestamp: new Date().toISOString(),\n            duration: Date.now() - session.startTime,\n            qualityMetrics: { ...this.qualityMetrics },\n            industryStandards: this.checkQualityTargets(),\n            overallScore: this.generateOverallQualityScore(),\n            statistics: {\n                totalSegments: session.transcriptSegments.length,\n                totalWords: session.performanceMetrics.totalWords,\n                averageLatency: this.qualityMetrics.latency,\n                averageConfidence: this.qualityMetrics.confidence,\n                errorCount: session.performanceMetrics.errorCount\n            },\n            recommendations: this.generateRecommendations()\n        };\n        \n        console.log('🎯 Quality Report Generated:', report);\n        return report;\n    }\n    \n    generateRecommendations() {\n        const recommendations = [];\n        \n        if (this.qualityMetrics.latency > this.thresholds.latency_target) {\n            recommendations.push('Consider optimizing audio chunk size to reduce latency');\n        }\n        \n        if (this.qualityMetrics.accuracy < this.thresholds.accuracy_target) {\n            recommendations.push('Review audio quality and background noise levels');\n        }\n        \n        if (this.qualityMetrics.wer > this.thresholds.wer_target) {\n            recommendations.push('Check microphone positioning and speaking clarity');\n        }\n        \n        if (this.qualityMetrics.completeness < 0.9) {\n            recommendations.push('Investigate audio chunk processing issues');\n        }\n        \n        return recommendations;\n    }\n}\n\n// Initialize global QA system\nwindow.audioQualityAssurance = new AudioQualityAssurance();\n\nconsole.log('✅ Audio Quality Assurance system loaded');"