/**\n * 📊 COMPREHENSIVE PERFORMANCE MONITOR: Real-time system performance tracking\n */\n\nclass ComprehensivePerformanceMonitor {\n    constructor() {\n        this.metrics = {\n            session: {\n                startTime: null,\n                duration: 0,\n                status: 'idle'\n            },\n            audio: {\n                chunksCollected: 0,\n                chunksProcessed: 0,\n                totalBytes: 0,\n                averageChunkSize: 0,\n                processingTimes: []\n            },\n            api: {\n                callsTotal: 0,\n                callsSuccessful: 0,\n                callsFailed: 0,\n                averageResponseTime: 0,\n                responseTimes: [],\n                lastCallTime: null\n            },\n            transcription: {\n                wordsTranscribed: 0,\n                charactersTranscribed: 0,\n                averageConfidence: 0,\n                confidenceScores: [],\n                interimResults: 0,\n                finalResults: 0\n            },\n            performance: {\n                memoryUsage: 0,\n                cpuUsage: 0,\n                networkLatency: 0,\n                frameRate: 0,\n                batteryLevel: null\n            },\n            quality: {\n                wer: 0, // Word Error Rate\n                accuracy: 0,\n                realTimeRatio: 0,\n                latencyTarget: 500, // Target latency in ms\n                qualityScore: 0\n            }\n        };\n        \n        this.updateInterval = null;\n        this.performanceObserver = null;\n        \n        this.initializeMonitoring();\n        console.log('📊 Comprehensive performance monitor initialized');\n    }\n    \n    initializeMonitoring() {\n        // Start continuous monitoring\n        this.startContinuousMonitoring();\n        \n        // Set up performance observer for web vitals\n        this.setupPerformanceObserver();\n        \n        // Monitor system resources\n        this.monitorSystemResources();\n        \n        // Set up event listeners for custom metrics\n        this.setupEventListeners();\n    }\n    \n    startContinuousMonitoring() {\n        this.updateInterval = setInterval(() => {\n            this.updateMetrics();\n            this.updateDashboard();\n        }, 1000); // Update every second\n    }\n    \n    setupPerformanceObserver() {\n        if ('PerformanceObserver' in window) {\n            try {\n                // Monitor navigation timing\n                this.performanceObserver = new PerformanceObserver((list) => {\n                    for (const entry of list.getEntries()) {\n                        this.processPerformanceEntry(entry);\n                    }\n                });\n                \n                this.performanceObserver.observe({ entryTypes: ['measure', 'navigation', 'resource'] });\n            } catch (error) {\n                console.warn('⚠️ Performance Observer not supported:', error);\n            }\n        }\n    }\n    \n    monitorSystemResources() {\n        // Monitor memory usage\n        if ('memory' in performance) {\n            setInterval(() => {\n                const memory = performance.memory;\n                this.metrics.performance.memoryUsage = {\n                    used: Math.round(memory.usedJSHeapSize / 1024 / 1024), // MB\n                    total: Math.round(memory.totalJSHeapSize / 1024 / 1024), // MB\n                    limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024) // MB\n                };\n            }, 5000);\n        }\n        \n        // Monitor battery if available\n        if ('getBattery' in navigator) {\n            navigator.getBattery().then((battery) => {\n                this.metrics.performance.batteryLevel = Math.round(battery.level * 100);\n                \n                battery.addEventListener('levelchange', () => {\n                    this.metrics.performance.batteryLevel = Math.round(battery.level * 100);\n                });\n            }).catch(() => {\n                // Battery API not available\n            });\n        }\n        \n        // Monitor network status\n        if ('connection' in navigator) {\n            const connection = navigator.connection;\n            this.metrics.performance.networkType = connection.effectiveType;\n            this.metrics.performance.downlink = connection.downlink;\n            \n            connection.addEventListener('change', () => {\n                this.metrics.performance.networkType = connection.effectiveType;\n                this.metrics.performance.downlink = connection.downlink;\n            });\n        }\n    }\n    \n    setupEventListeners() {\n        // Listen for session events\n        window.addEventListener('sessionStarted', (event) => {\n            this.startSession(event.detail.sessionId);\n        });\n        \n        // Listen for audio chunk events\n        window.addEventListener('audioChunkCollected', (event) => {\n            this.recordAudioChunk(event.detail);\n        });\n        \n        // Listen for API call events\n        window.addEventListener('apiCallStarted', (event) => {\n            this.recordAPICallStart(event.detail);\n        });\n        \n        window.addEventListener('apiCallCompleted', (event) => {\n            this.recordAPICallComplete(event.detail);\n        });\n        \n        // Listen for transcription events\n        window.addEventListener('interimTranscription', (event) => {\n            this.recordInterimResult(event.detail);\n        });\n        \n        window.addEventListener('transcriptionComplete', (event) => {\n            this.recordFinalResult(event.detail);\n        });\n    }\n    \n    startSession(sessionId) {\n        this.metrics.session = {\n            id: sessionId,\n            startTime: Date.now(),\n            duration: 0,\n            status: 'active'\n        };\n        \n        // Reset session-specific metrics\n        this.metrics.audio.chunksCollected = 0;\n        this.metrics.audio.chunksProcessed = 0;\n        this.metrics.audio.totalBytes = 0;\n        this.metrics.api.callsTotal = 0;\n        this.metrics.api.callsSuccessful = 0;\n        this.metrics.api.callsFailed = 0;\n        this.metrics.transcription.wordsTranscribed = 0;\n        this.metrics.transcription.interimResults = 0;\n        \n        console.log(`📊 Performance monitoring started for session: ${sessionId}`);\n    }\n    \n    recordAudioChunk(chunkData) {\n        this.metrics.audio.chunksCollected++;\n        this.metrics.audio.totalBytes += chunkData.size || 0;\n        this.metrics.audio.averageChunkSize = Math.round(this.metrics.audio.totalBytes / this.metrics.audio.chunksCollected);\n    }\n    \n    recordAPICallStart(callData) {\n        this.metrics.api.callsTotal++;\n        this.metrics.api.lastCallTime = Date.now();\n    }\n    \n    recordAPICallComplete(callData) {\n        const responseTime = Date.now() - this.metrics.api.lastCallTime;\n        this.metrics.api.responseTimes.push(responseTime);\n        \n        // Keep only last 50 response times\n        if (this.metrics.api.responseTimes.length > 50) {\n            this.metrics.api.responseTimes.shift();\n        }\n        \n        this.metrics.api.averageResponseTime = Math.round(\n            this.metrics.api.responseTimes.reduce((a, b) => a + b, 0) / this.metrics.api.responseTimes.length\n        );\n        \n        if (callData.success) {\n            this.metrics.api.callsSuccessful++;\n        } else {\n            this.metrics.api.callsFailed++;\n        }\n    }\n    \n    recordInterimResult(resultData) {\n        this.metrics.transcription.interimResults++;\n        \n        if (resultData.text) {\n            const words = resultData.text.split(' ').length;\n            this.metrics.transcription.wordsTranscribed += words;\n            this.metrics.transcription.charactersTranscribed += resultData.text.length;\n        }\n        \n        if (resultData.confidence) {\n            this.metrics.transcription.confidenceScores.push(resultData.confidence);\n            this.updateAverageConfidence();\n        }\n    }\n    \n    recordFinalResult(resultData) {\n        this.metrics.transcription.finalResults++;\n        this.recordInterimResult(resultData); // Also count as interim for totals\n    }\n    \n    updateAverageConfidence() {\n        const scores = this.metrics.transcription.confidenceScores;\n        if (scores.length > 0) {\n            this.metrics.transcription.averageConfidence = \n                scores.reduce((a, b) => a + b, 0) / scores.length;\n        }\n    }\n    \n    updateMetrics() {\n        // Update session duration\n        if (this.metrics.session.startTime) {\n            this.metrics.session.duration = Date.now() - this.metrics.session.startTime;\n        }\n        \n        // Calculate quality metrics\n        this.calculateQualityMetrics();\n        \n        // Update real-time ratio\n        this.updateRealTimeRatio();\n    }\n    \n    calculateQualityMetrics() {\n        // Calculate accuracy based on confidence scores\n        this.metrics.quality.accuracy = this.metrics.transcription.averageConfidence * 100;\n        \n        // Calculate quality score (composite metric)\n        const latencyScore = Math.max(0, 100 - (this.metrics.api.averageResponseTime / 10));\n        const accuracyScore = this.metrics.quality.accuracy;\n        const reliabilityScore = this.metrics.api.callsTotal > 0 ? \n            (this.metrics.api.callsSuccessful / this.metrics.api.callsTotal) * 100 : 100;\n        \n        this.metrics.quality.qualityScore = Math.round(\n            (latencyScore * 0.3 + accuracyScore * 0.4 + reliabilityScore * 0.3)\n        );\n    }\n    \n    updateRealTimeRatio() {\n        if (this.metrics.session.duration > 0 && this.metrics.api.averageResponseTime > 0) {\n            // Real-time ratio: how much faster/slower than real-time we are\n            const processingTime = this.metrics.api.averageResponseTime * this.metrics.api.callsTotal;\n            this.metrics.quality.realTimeRatio = this.metrics.session.duration / processingTime;\n        }\n    }\n    \n    updateDashboard() {\n        const dashboard = this.getDashboardElement();\n        if (!dashboard) return;\n        \n        const uptime = this.formatDuration(this.metrics.session.duration);\n        const successRate = this.metrics.api.callsTotal > 0 ? \n            Math.round((this.metrics.api.callsSuccessful / this.metrics.api.callsTotal) * 100) : 100;\n        \n        dashboard.innerHTML = `\n            <div class=\"performance-dashboard\">\n                <h4>📊 Performance Monitor</h4>\n                \n                <div class=\"metrics-grid\">\n                    <div class=\"metric-group\">\n                        <h5>🎵 Audio</h5>\n                        <div class=\"metric\">Chunks: ${this.metrics.audio.chunksCollected}</div>\n                        <div class=\"metric\">Size: ${this.formatBytes(this.metrics.audio.totalBytes)}</div>\n                        <div class=\"metric\">Avg: ${this.formatBytes(this.metrics.audio.averageChunkSize)}</div>\n                    </div>\n                    \n                    <div class=\"metric-group\">\n                        <h5>🌐 API</h5>\n                        <div class=\"metric\">Calls: ${this.metrics.api.callsTotal}</div>\n                        <div class=\"metric\">Success: ${successRate}%</div>\n                        <div class=\"metric\">Latency: ${this.metrics.api.averageResponseTime}ms</div>\n                    </div>\n                    \n                    <div class=\"metric-group\">\n                        <h5>📝 Transcription</h5>\n                        <div class=\"metric\">Words: ${this.metrics.transcription.wordsTranscribed}</div>\n                        <div class=\"metric\">Confidence: ${Math.round(this.metrics.quality.accuracy)}%</div>\n                        <div class=\"metric\">Interim: ${this.metrics.transcription.interimResults}</div>\n                    </div>\n                    \n                    <div class=\"metric-group\">\n                        <h5>⚡ Performance</h5>\n                        <div class=\"metric\">Quality: ${this.metrics.quality.qualityScore}%</div>\n                        <div class=\"metric\">Uptime: ${uptime}</div>\n                        <div class=\"metric\">Memory: ${this.formatMemory()}</div>\n                    </div>\n                </div>\n                \n                <div class=\"performance-indicators\">\n                    <div class=\"indicator ${this.getLatencyClass()}\">\n                        🚀 Latency: ${this.metrics.api.averageResponseTime}ms\n                    </div>\n                    <div class=\"indicator ${this.getQualityClass()}\">\n                        🎯 Quality: ${this.metrics.quality.qualityScore}%\n                    </div>\n                    <div class=\"indicator ${this.getReliabilityClass()}\">\n                        🛡️ Reliability: ${successRate}%\n                    </div>\n                </div>\n            </div>\n        `;\n    }\n    \n    getDashboardElement() {\n        let dashboard = document.getElementById('performance-dashboard');\n        if (!dashboard) {\n            dashboard = document.createElement('div');\n            dashboard.id = 'performance-dashboard';\n            dashboard.style.cssText = `\n                position: fixed;\n                bottom: 10px;\n                left: 10px;\n                background: rgba(0, 0, 0, 0.9);\n                color: white;\n                padding: 15px;\n                border-radius: 8px;\n                font-family: monospace;\n                font-size: 11px;\n                z-index: 10000;\n                max-width: 400px;\n                box-shadow: 0 4px 8px rgba(0,0,0,0.3);\n            `;\n            \n            // Add CSS for performance dashboard\n            const style = document.createElement('style');\n            style.textContent = `\n                .performance-dashboard .metrics-grid {\n                    display: grid;\n                    grid-template-columns: 1fr 1fr;\n                    gap: 10px;\n                    margin: 10px 0;\n                }\n                .performance-dashboard .metric-group {\n                    background: rgba(255,255,255,0.1);\n                    padding: 8px;\n                    border-radius: 4px;\n                }\n                .performance-dashboard .metric-group h5 {\n                    margin: 0 0 5px 0;\n                    font-size: 12px;\n                }\n                .performance-dashboard .metric {\n                    margin: 2px 0;\n                }\n                .performance-dashboard .performance-indicators {\n                    display: flex;\n                    gap: 5px;\n                    margin-top: 10px;\n                }\n                .performance-dashboard .indicator {\n                    flex: 1;\n                    padding: 4px;\n                    border-radius: 3px;\n                    text-align: center;\n                    font-size: 10px;\n                }\n                .performance-dashboard .indicator.excellent {\n                    background: rgba(40, 167, 69, 0.3);\n                }\n                .performance-dashboard .indicator.good {\n                    background: rgba(255, 193, 7, 0.3);\n                }\n                .performance-dashboard .indicator.poor {\n                    background: rgba(220, 53, 69, 0.3);\n                }\n            `;\n            document.head.appendChild(style);\n            \n            document.body.appendChild(dashboard);\n        }\n        return dashboard;\n    }\n    \n    getLatencyClass() {\n        const latency = this.metrics.api.averageResponseTime;\n        if (latency < 500) return 'excellent';\n        if (latency < 1000) return 'good';\n        return 'poor';\n    }\n    \n    getQualityClass() {\n        const quality = this.metrics.quality.qualityScore;\n        if (quality > 80) return 'excellent';\n        if (quality > 60) return 'good';\n        return 'poor';\n    }\n    \n    getReliabilityClass() {\n        const reliability = this.metrics.api.callsTotal > 0 ? \n            (this.metrics.api.callsSuccessful / this.metrics.api.callsTotal) * 100 : 100;\n        if (reliability > 95) return 'excellent';\n        if (reliability > 85) return 'good';\n        return 'poor';\n    }\n    \n    formatDuration(ms) {\n        const seconds = Math.floor(ms / 1000);\n        const minutes = Math.floor(seconds / 60);\n        if (minutes > 0) {\n            return `${minutes}m ${seconds % 60}s`;\n        }\n        return `${seconds}s`;\n    }\n    \n    formatBytes(bytes) {\n        if (bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];\n    }\n    \n    formatMemory() {\n        const memory = this.metrics.performance.memoryUsage;\n        if (typeof memory === 'object') {\n            return `${memory.used}MB`;\n        }\n        return 'N/A';\n    }\n    \n    getPerformanceReport() {\n        return {\n            timestamp: Date.now(),\n            session: this.metrics.session,\n            summary: {\n                qualityScore: this.metrics.quality.qualityScore,\n                averageLatency: this.metrics.api.averageResponseTime,\n                successRate: this.metrics.api.callsTotal > 0 ? \n                    (this.metrics.api.callsSuccessful / this.metrics.api.callsTotal) * 100 : 100,\n                wordsPerMinute: this.calculateWordsPerMinute(),\n                accuracy: this.metrics.quality.accuracy\n            },\n            metrics: this.metrics\n        };\n    }\n    \n    calculateWordsPerMinute() {\n        if (this.metrics.session.duration > 0) {\n            const minutes = this.metrics.session.duration / (1000 * 60);\n            return Math.round(this.metrics.transcription.wordsTranscribed / minutes);\n        }\n        return 0;\n    }\n    \n    stop() {\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n        }\n        if (this.performanceObserver) {\n            this.performanceObserver.disconnect();\n        }\n        \n        this.metrics.session.status = 'stopped';\n        console.log('📊 Performance monitoring stopped');\n    }\n}\n\n// Initialize global performance monitor\nwindow.comprehensivePerformanceMonitor = new ComprehensivePerformanceMonitor();\n\nconsole.log('✅ Comprehensive performance monitor loaded');"