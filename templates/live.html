<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mina — Live Transcription</title>
  <!-- Tailwind for quick, consistent styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- We DO NOT hard‑reference /socket.io/script to avoid race/errors.
       The app will load same‑origin first, then CDN as fallback at runtime. -->
  <style>
    @keyframes shimmer { 100% { translate: 100% 0 } }
    @keyframes pulseSoft { 0%,100%{ transform: scale(1)} 50%{ transform: scale(1.04)} }
    .pulse-soft { animation: pulseSoft 1.2s ease-in-out infinite; }
    .shimmer::after { content: ""; position: absolute; inset: 0; translate: -100% 0; background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,.15) 50%, transparent 100%); animation: shimmer 1.6s infinite; }
    #debugArea { font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 text-slate-100">
  <div class="max-w-6xl mx-auto px-4 py-6 md:py-10 space-y-6">
    <!-- Header -->
    <header class="flex items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-xl bg-gradient-to-br from-indigo-500 to-fuchsia-500 shadow-lg"></div>
        <div>
          <h1 class="text-2xl md:text-3xl font-bold">Mina — Live Transcription</h1>
          <p class="text-sm text-slate-400">Unified live transcript that replaces with final on stop</p>
        </div>
      </div>
      <div class="hidden md:flex items-center gap-2 text-sm">
        <span id="wsStatus" class="px-3 py-1 rounded-full bg-slate-800/80">Disconnected</span>
        <span id="micStatus" class="px-3 py-1 rounded-full bg-slate-800/80">Idle</span>
      </div>
    </header>

    <!-- Controls -->
    <section class="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
      <div class="flex items-center gap-4">
        <button id="micButton" class="relative w-24 h-24 md:w-28 md:h-28 rounded-full bg-gradient-to-br from-indigo-500 to-fuchsia-500 shadow-xl hover:scale-105 transition flex items-center justify-center">
          <svg id="micIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="w-9 h-9"><path fill="currentColor" d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3m5-3a1 1 0 0 1 2 0a7 7 0 0 1-6 6.92V21h3a1 1 0 1 1 0 2H8a1 1 0 1 1 0-2h3v-3.08A7 7 0 0 1 5 11a1 1 0 1 1 2 0a5 5 0 0 0 10 0"/></svg>
        </button>
        <div>
          <div class="text-slate-400 text-sm">Session</div>
          <div id="sess" class="px-3 py-1 rounded-full bg-slate-800/70 text-slate-200 text-sm">—</div>
        </div>
      </div>
      <div class="flex items-center gap-3 md:hidden">
        <span id="wsStatus_m" class="px-3 py-1 rounded-full bg-slate-800/80">Disconnected</span>
        <span id="micStatus_m" class="px-3 py-1 rounded-full bg-slate-800/80">Idle</span>
      </div>
    </section>

    <!-- Meter -->
    <div class="h-2 rounded-full bg-slate-800 overflow-hidden">
      <div id="meterFill" class="h-full w-0 bg-gradient-to-r from-cyan-400 via-indigo-500 to-fuchsia-500 transition-[width] duration-150"></div>
    </div>

    <!-- Unified Transcript Panel -->
    <div class="rounded-2xl bg-slate-900/60 border border-white/5 p-4">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-lg font-semibold">Transcript</h2>
        <div class="flex items-center gap-2">
          <span id="modeBadge" class="px-2 py-0.5 rounded-full text-xs bg-emerald-600/60">Live</span>
        </div>
      </div>
      <div id="noteBar" class="hidden mb-3 px-3 py-2 rounded-xl bg-yellow-500/10 text-yellow-200 text-sm border border-yellow-500/20"></div>
      <div id="transcriptBox" class="min-h-[220px] whitespace-pre-wrap text-slate-100"></div>
    </div>

    <!-- Actions -->
    <div class="flex flex-wrap items-center gap-3">
      <button id="btnCopy" class="px-4 py-2 rounded-xl bg-slate-800 hover:bg-slate-700">Copy</button>
      <button id="btnExport" class="px-4 py-2 rounded-xl bg-slate-800 hover:bg-slate-700">Export .txt</button>
      <button id="btnClear" class="px-4 py-2 rounded-xl bg-slate-800 hover:bg-slate-700">Clear</button>
      <button id="btnDebug" class="ml-auto px-4 py-2 rounded-xl bg-black/60 hover:bg-black/70">Debug</button>
    </div>

    <!-- Debug + Diagnostics -->
    <div id="debugWrap" class="hidden">
      <div class="rounded-2xl bg-black/70 border border-white/10 p-3">
        <div class="text-xs text-slate-400 mb-2">Console</div>
        <div id="debugArea" class="text-[11px] text-green-400 max-h-56 overflow-y-auto"></div>
        <div id="diag" class="mt-3 text-[11px] text-slate-300 space-y-1"></div>
        <div class="mt-3 flex items-center gap-2">
          <button id="btnRunTests" class="px-3 py-1.5 rounded-lg bg-slate-800 hover:bg-slate-700 text-[12px]">Run Self‑Tests</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ------- Minimal helpers available before boot -------
    function softNote(msg){
      var el = document.getElementById('noteBar');
      if(!el) return; el.textContent = msg; el.classList.remove('hidden');
    }
    function clearSoftNote(){ var el=document.getElementById('noteBar'); if(!el) return; el.classList.add('hidden'); el.textContent=''; }
    function logToView(){
      const logView = document.getElementById('debugArea');
      return function(...args){
        const line = args.map(x => typeof x === 'object' ? JSON.stringify(x) : String(x)).join(' ');
        console.log('[mina]', ...args);
        if (!logView) return;
        const div = document.createElement('div');
        div.textContent = line; logView.appendChild(div); logView.scrollTop = logView.scrollHeight;
      }
    }
    const log = logToView();

    // ------- DOM refs (used later in boot) -------
    const micBtn = document.getElementById('micButton');
    const meterFill = document.getElementById('meterFill');
    const wsStatus = document.getElementById('wsStatus');
    const wsStatus_m = document.getElementById('wsStatus_m');
    const micStatus = document.getElementById('micStatus');
    const micStatus_m = document.getElementById('micStatus_m');
    const sess = document.getElementById('sess');
    const transcriptBox = document.getElementById('transcriptBox');
    const modeBadge = document.getElementById('modeBadge');
    const btnCopy = document.getElementById('btnCopy');
    const btnExport = document.getElementById('btnExport');
    const btnClear = document.getElementById('btnClear');
    const btnDebug = document.getElementById('btnDebug');
    const debugWrap = document.getElementById('debugWrap');
    const diagEl = document.getElementById('diag');
    const btnRunTests = document.getElementById('btnRunTests');

    function setWs(status) { if (wsStatus) wsStatus.textContent = status; if (wsStatus_m) wsStatus_m.textContent = status; }
    function setMic(status) { if (micStatus) micStatus.textContent = status; if (micStatus_m) micStatus_m.textContent = status; }

    // ------- Safe Socket.IO loader with same-origin then CDN fallback -------
    function loadScript(src){
      return new Promise((resolve,reject)=>{ const s=document.createElement('script'); s.src=src; s.async=true; s.crossOrigin='anonymous'; s.onload=resolve; s.onerror=()=>reject(new Error('Failed to load '+src)); document.head.appendChild(s); });
    }
    async function ensureSocketIO(){
      if (window.io) return true;
      // Try same-origin (Flask-SocketIO serves this if available)
      try { await loadScript('/socket.io/socket.io.js'); } catch(e){ log('socket.io same-origin load failed:', e.message); }
      if (window.io) return true;
      // Fallback to CDN (Socket.IO 4.x; compatible with python-socketio 5.x)
      try { await loadScript('https://cdn.socket.io/4.7.5/socket.io.min.js'); } catch(e){ log('socket.io CDN load failed:', e.message); }
      return !!window.io;
    }

    // ------- App bootstrap (runs after io is ensured) -------
    async function boot(){
      const SESSION_ID = String(Date.now());
      if (sess) sess.textContent = SESSION_ID;

      // Guard: show explicit error if Socket.IO client is unavailable
      const ok = await ensureSocketIO();
      if (!ok){
        softNote('Socket.IO client failed to load. Ensure your server exposes /socket.io/* or allow CDN access.');
        if (diagEl) diagEl.innerHTML = '<div>TEST: window.io ❌ (client script missing)</div>' +
          '<div>Checked /socket.io/socket.io.js then CDN.</div>';
        setWs('Client unavailable'); setMic('Idle');
        return; // prevents "io is not defined"
      }

      const socket = window.io({
        path: '/socket.io',
        transports: ['polling'],
        upgrade: false,
        reconnection: true,
        reconnectionAttempts: 30,
        reconnectionDelay: 500,
        timeout: 10000,
      });

      socket.on('connect', () => {
        setWs('Connected');
        log('socket connected id=', socket.id, 'transport=', socket.io.engine.transport.name);
        socket.emit('join_session', { session_id: SESSION_ID });
        if (diagEl) diagEl.insertAdjacentHTML('beforeend', `<div>TEST: connect ✅ (${socket.io.engine.transport.name})</div>`);
      });
      socket.on('disconnect', r => { setWs('Disconnected'); log('socket disconnected', r); });
      socket.on('connect_error', e => { setWs('Conn error'); log('connect_error', e?.message || e); });

      // Unified behavior: interim stream replaced by final on stop
      let interimStream = '';
      let lastInterim = '';
      let awaitingFinal = false;

      function showNote(msg){ softNote(msg); }
      function hideNote(){ clearSoftNote(); }

      socket.on('server_hello', m => log('server_hello', m));
      socket.on('error', e => { log('socket error', e); if (e && e.detail) showNote('[server] '+e.detail); });
      socket.on('socket_error', e => { log('transcription error', e); if (e && e.detail) showNote('[transcription] '+e.detail); });
      socket.on('interim_transcript', p => {
        const t = (p?.text || '').trim();
        if (!t) return; if (t === lastInterim) return; lastInterim = t;
        interimStream += (interimStream ? ' ' : '') + t;
        transcriptBox.textContent = interimStream;
        if (modeBadge){ modeBadge.textContent = 'Live'; modeBadge.className = 'px-2 py-0.5 rounded-full text-xs bg-emerald-600/60'; }
      });
      socket.on('final_transcript', p => {
        const finalText = (p?.text || '').trim();
        awaitingFinal = false; hideNote();
        if (finalText) { transcriptBox.textContent = finalText; }
        if (modeBadge){ modeBadge.textContent = 'Final'; modeBadge.className = 'px-2 py-0.5 rounded-full text-xs bg-sky-600/60'; }
        transcriptBox.classList.remove('shimmer','relative');
      });

      // ------- Recording pipeline -------
      let stream = null, mediaRecorder = null; let rafId = null; let audioCtx = null, analyser = null, dataArray = null;

      function startMeter(s){
        try{
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioCtx.createMediaStreamSource(s);
          analyser = audioCtx.createAnalyser(); analyser.fftSize = 512;
          dataArray = new Uint8Array(analyser.frequencyBinCount); source.connect(analyser);
          const draw = () => {
            analyser.getByteTimeDomainData(dataArray);
            let peak = 0; for (let i=0;i<dataArray.length;i++){ const v=Math.abs(dataArray[i]-128); if(v>peak) peak=v; }
            const pct = Math.min(100, Math.round((peak/128)*100)); meterFill.style.width = pct + '%';
            rafId = requestAnimationFrame(draw);
          }; draw();
        } catch {}
      }
      function stopMeter(){ if (rafId) cancelAnimationFrame(rafId), rafId=null; try{ audioCtx?.close(); }catch{} audioCtx=null; analyser=null; dataArray=null; meterFill.style.width='0%'; }

      async function startRecording(){
        clearSoftNote();
        micBtn.classList.add('pulse-soft'); setMic('Recording…');
        interimStream=''; lastInterim=''; awaitingFinal=false; transcriptBox.textContent='';
        if (modeBadge){ modeBadge.textContent='Live'; modeBadge.className='px-2 py-0.5 rounded-full text-xs bg-emerald-600/60'; }

        socket.emit('join_session', { session_id: SESSION_ID });
        try { stream = await navigator.mediaDevices.getUserMedia({ audio: true }); }
        catch(err){ softNote('[mic] '+(err?.message||'Microphone access failed')); setMic('Idle'); micBtn.classList.remove('pulse-soft'); return; }

        let mime = 'audio/webm;codecs=opus';
        if (!MediaRecorder.isTypeSupported?.(mime)){
          if (MediaRecorder.isTypeSupported?.('audio/webm')) mime='audio/webm';
          else if (MediaRecorder.isTypeSupported?.('audio/ogg;codecs=opus')) mime='audio/ogg;codecs=opus';
          else mime='';
        }
        try { mediaRecorder = new MediaRecorder(stream, { mimeType: mime, audioBitsPerSecond: 128000 }); }
        catch(err){ softNote('[recorder] '+(err?.message||'Failed to initialize MediaRecorder')); setMic('Idle'); micBtn.classList.remove('pulse-soft'); try{ stream.getTracks().forEach(t=>t.stop()); }catch{} stream=null; return; }

        startMeter(stream);
        mediaRecorder.ondataavailable = async (e)=>{
          try{
            if (!e.data || e.data.size===0) return;
            const buf = await e.data.arrayBuffer();
            const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
            socket.emit('audio_chunk', { session_id: SESSION_ID, audio_data_b64: b64, mime: e.data.type || mime || 'audio/webm' });
          }catch(err){ /* ignore */ }
        };
        mediaRecorder.onstop = ()=>{
          stopMeter(); setMic('Stopped'); micBtn.classList.remove('pulse-soft'); awaitingFinal=true;
          transcriptBox.classList.add('relative','shimmer');
          setTimeout(()=>{ socket.emit('finalize_session', { session_id: SESSION_ID, mime: mediaRecorder?.mimeType || mime || 'audio/webm' }); }, 300);
          try{ stream.getTracks().forEach(t=>t.stop()); }catch{} stream=null;
        };
        mediaRecorder.start(1200);
      }
      function stopRecording(){ if (mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop(); }

      micBtn.addEventListener('click', ()=>{
        const active = mediaRecorder && mediaRecorder.state !== 'inactive';
        if (!active) startRecording(); else stopRecording();
      });

      btnCopy.addEventListener('click', async ()=>{ const text = transcriptBox.textContent || ''; try{ await navigator.clipboard.writeText(text); }catch{} });
      btnExport.addEventListener('click', ()=>{ const blob = new Blob([transcriptBox.textContent||''],{type:'text/plain'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`mina-transcript-${SESSION_ID}.txt`; a.click(); URL.revokeObjectURL(a.href); });
      btnClear.addEventListener('click', ()=>{ transcriptBox.textContent=''; clearSoftNote(); if (modeBadge){ modeBadge.textContent='Live'; modeBadge.className='px-2 py-0.5 rounded-full text-xs bg-emerald-600/60'; } });
      btnDebug.addEventListener('click', ()=>{ debugWrap.classList.toggle('hidden'); });

      setWs(socket.connected ? 'Connected' : 'Disconnected'); setMic('Idle');

      // ---------- SELF‑TESTS (act like test cases) ----------
      function runSelfTests(){
        if (!diagEl) return;
        diagEl.innerHTML = '';
        // 1) Client presence
        diagEl.insertAdjacentHTML('beforeend', `<div>TEST: window.io ${window.io ? '✅' : '❌'}</div>`);
        // 2) Connectivity ACK
        try {
          const pingStart = Date.now();
          socket.timeout(3000).emit('server_ping', { t: pingStart }, (err, res)=>{
            if (err) diagEl.insertAdjacentHTML('beforeend', `<div>TEST: server_ping ❌ (no ack within 3s)</div>`);
            else diagEl.insertAdjacentHTML('beforeend', `<div>TEST: server_ping ✅ ${Date.now()-pingStart}ms</div>`);
          });
        } catch { diagEl.insertAdjacentHTML('beforeend', `<div>TEST: server_ping ❌ (exception)</div>`); }
        // 3) MediaRecorder support
        const hasMR = !!window.MediaRecorder;
        const canWebm = hasMR && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm;codecs=opus');
        const canOgg = hasMR && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/ogg;codecs=opus');
        diagEl.insertAdjacentHTML('beforeend', `<div>TEST: MediaRecorder ${hasMR ? '✅' : '❌'}</div>`);
        diagEl.insertAdjacentHTML('beforeend', `<div>TEST: webm/opus ${canWebm ? '✅' : '❌'} • ogg/opus ${canOgg ? '✅' : '❌'}</div>`);
      }
      if (btnRunTests) btnRunTests.addEventListener('click', runSelfTests);
      // Auto‑run once so devs see signals quickly
      runSelfTests();
    }

    // Boot once DOM is ready
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot); else boot();
  </script>
</body>
</html>
