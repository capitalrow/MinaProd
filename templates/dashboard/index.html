{% extends "base.html" %}

{% block title %}Dashboard - Mina{% endblock %}

{% block extra_css %}
<style>
.dashboard-container {
    min-height: calc(100vh - var(--header-height));
    padding: var(--space-8) 0;
}

.dashboard-header {
    margin-bottom: var(--space-8);
    animation: fadeInUp 0.6s ease-out;
}

.welcome-title {
    font-size: var(--font-size-4xl);
    font-weight: var(--font-weight-bold);
    background: var(--gradient-primary);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: var(--space-2);
}

.welcome-subtitle {
    color: var(--color-text-secondary);
    font-size: var(--font-size-lg);
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-6);
    margin-bottom: var(--space-8);
}

.stat-card {
    background: var(--glass-bg);
    backdrop-filter: var(--backdrop-blur);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-2xl);
    padding: var(--space-6);
    transition: all var(--transition-base);
    position: relative;
    overflow: hidden;
    animation: fadeInUp 0.6s ease-out;
    animation-fill-mode: both;
}

.stat-card:nth-child(1) { animation-delay: 0.1s; }
.stat-card:nth-child(2) { animation-delay: 0.2s; }
.stat-card:nth-child(3) { animation-delay: 0.3s; }

.stat-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: var(--gradient-primary);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.stat-card:hover {
    transform: translateY(-4px);
    border-color: var(--color-primary);
}

.stat-card:hover::before {
    opacity: 1;
}

.stat-icon {
    width: 64px;
    height: 64px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-xl);
    margin-bottom: var(--space-4);
    position: relative;
    overflow: hidden;
}

.stat-icon::before {
    content: '';
    position: absolute;
    inset: 0;
    background: inherit;
    opacity: 0.1;
    filter: blur(20px);
}

.stat-content {
    position: relative;
}

.stat-label {
    font-size: var(--font-size-sm);
    color: var(--color-text-tertiary);
    font-weight: var(--font-weight-medium);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: var(--space-2);
}

.stat-value {
    font-size: var(--font-size-4xl);
    font-weight: var(--font-weight-bold);
    color: var(--color-text-primary);
    line-height: 1;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-6);
    animation: fadeInUp 0.6s ease-out 0.4s;
    animation-fill-mode: both;
}

.section-title {
    font-size: var(--font-size-2xl);
    font-weight: var(--font-weight-semibold);
    color: var(--color-text-primary);
}

.section-link {
    color: var(--color-primary);
    font-size: var(--font-size-sm);
    font-weight: var(--font-weight-medium);
    text-decoration: none;
    display: flex;
    align-items: center;
    gap: var(--space-1);
    transition: gap var(--transition-base);
}

.section-link:hover {
    gap: var(--space-2);
}

.meetings-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
}

.meeting-card {
    background: var(--glass-bg);
    backdrop-filter: var(--backdrop-blur);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-xl);
    padding: var(--space-6);
    transition: all var(--transition-base);
    cursor: pointer;
    position: relative;
    overflow: hidden;
    animation: fadeInUp 0.6s ease-out;
    animation-fill-mode: both;
}

.meeting-card-processing {
    opacity: 0.7;
    cursor: not-allowed;
    border-style: dashed;
}

.meeting-card:nth-child(1) { animation-delay: 0.5s; }
.meeting-card:nth-child(2) { animation-delay: 0.6s; }
.meeting-card:nth-child(3) { animation-delay: 0.7s; }

.meeting-card::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 4px;
    background: var(--gradient-primary);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.meeting-card:hover {
    transform: translateX(8px);
    border-color: var(--color-primary);
}

.meeting-card:hover::before {
    opacity: 1;
}

.meeting-title {
    font-size: var(--font-size-lg);
    font-weight: var(--font-weight-semibold);
    color: var(--color-text-primary);
    margin-bottom: var(--space-2);
}

.meeting-date {
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary);
    margin-bottom: var(--space-3);
}

.meeting-summary {
    font-size: var(--font-size-sm);
    color: var(--color-text-tertiary);
    line-height: var(--line-height-relaxed);
}

.empty-state {
    background: var(--glass-bg);
    backdrop-filter: var(--backdrop-blur);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-2xl);
    padding: var(--space-12);
    text-align: center;
    animation: fadeInUp 0.6s ease-out 0.5s;
    animation-fill-mode: both;
}

.empty-state-icon {
    width: 80px;
    height: 80px;
    margin: 0 auto var(--space-6);
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--glass-bg);
    border-radius: var(--radius-full);
    border: 2px solid var(--glass-border);
}

.empty-state-title {
    font-size: var(--font-size-2xl);
    font-weight: var(--font-weight-semibold);
    color: var(--color-text-primary);
    margin-bottom: var(--space-2);
}

.empty-state-description {
    font-size: var(--font-size-base);
    color: var(--color-text-tertiary);
    margin-bottom: var(--space-6);
}

.tasks-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
    margin-top: var(--space-6);
}

.task-card {
    background: var(--glass-bg);
    backdrop-filter: var(--backdrop-blur);
    border: 1px solid var(--glass-border);
    border-radius: var(--radius-lg);
    padding: var(--space-4);
    transition: all var(--transition-base);
    animation: fadeInUp 0.6s ease-out;
    animation-fill-mode: both;
}

.task-card:nth-child(1) { animation-delay: 0.5s; }
.task-card:nth-child(2) { animation-delay: 0.6s; }
.task-card:nth-child(3) { animation-delay: 0.7s; }
.task-card:nth-child(4) { animation-delay: 0.8s; }
.task-card:nth-child(5) { animation-delay: 0.9s; }

.task-card:hover {
    border-color: var(--color-primary);
    transform: translateX(4px);
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@media (max-width: 768px) {
    .stats-grid {
        grid-template-columns: 1fr;
    }
    
    .welcome-title {
        font-size: var(--font-size-3xl);
    }
}
</style>
{% endblock %}

{% block content %}
<div class="container dashboard-container">
    <div class="dashboard-header">
        <div class="flex justify-between items-center">
            <div>
                <h1 class="welcome-title">Welcome back, {{ current_user.username }}!</h1>
                <p class="welcome-subtitle">Here's what's happening with your meetings</p>
            </div>
            <a href="{{ url_for('pages.live') }}" class="btn btn-primary">
                <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
                </svg>
                Start Recording
            </a>
        </div>
    </div>

    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-icon" style="background: var(--gradient-primary);">
                <svg width="32" height="32" fill="white" viewBox="0 0 24 24">
                    <path d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                </svg>
            </div>
            <div class="stat-content">
                <p class="stat-label">Total Meetings</p>
                <p class="stat-value">{{ total_meetings|default(0) }}</p>
            </div>
        </div>

        <div class="stat-card">
            <div class="stat-icon" style="background: linear-gradient(135deg, #10b981 0%, #3b82f6 100%);">
                <svg width="32" height="32" fill="none" stroke="white" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"/>
                </svg>
            </div>
            <div class="stat-content">
                <p class="stat-label">Action Items</p>
                <p class="stat-value">{{ total_tasks|default(0) }}</p>
            </div>
        </div>

        <div class="stat-card">
            <div class="stat-icon" style="background: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%);">
                <svg width="32" height="32" fill="none" stroke="white" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
                </svg>
            </div>
            <div class="stat-content">
                <p class="stat-label">Hours Saved</p>
                <p class="stat-value">{{ hours_saved|default(0) }}</p>
            </div>
        </div>
    </div>

    <div class="section-header">
        <h2 class="section-title">Recent Meetings</h2>
        <a href="{{ url_for('dashboard.meetings') }}" class="section-link">
            View all
            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
            </svg>
        </a>
    </div>

    {% if recent_meetings and recent_meetings|length > 0 %}
    <div class="meetings-list">
        {% for meeting in recent_meetings %}
        <div class="meeting-card {% if not meeting.session or not meeting.session.external_id %}meeting-card-processing{% endif %}" 
             data-meeting-id="{{ meeting.id }}" 
             data-meeting-title="{{ meeting.title or 'Untitled Meeting' }}"
             {% if meeting.session and meeting.session.external_id %}data-session-id="{{ meeting.session.external_id }}"{% endif %}>
            <div class="flex justify-between items-start">
                <div class="flex-1">
                    <h3 class="meeting-title">{{ meeting.title or 'Untitled Meeting' }}</h3>
                    <p class="meeting-date">{{ meeting.created_at.strftime('%B %d, %Y at %I:%M %p') }}</p>
                    {% if meeting.summary %}
                    <p class="meeting-summary">{{ meeting.summary[:150] }}{% if meeting.summary|length > 150 %}...{% endif %}</p>
                    {% elif not meeting.session or not meeting.session.external_id %}
                    <p class="meeting-summary" style="color: var(--color-text-secondary); font-style: italic;">
                        Transcription being processed... Insights will appear shortly.
                    </p>
                    {% endif %}
                </div>
                <div class="flex items-center gap-3">
                    {% if not meeting.session or not meeting.session.external_id %}
                    <span class="badge badge-warning" title="Session is being processed">
                        <svg width="12" height="12" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display: inline; margin-right: 4px;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                        Processing
                    </span>
                    {% else %}
                        {% if meeting.duration %}
                        <span class="badge badge-primary">{{ (meeting.duration / 60)|round|int }} min</span>
                        {% endif %}
                        <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="opacity: 0.5;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                        </svg>
                    {% endif %}
                </div>
            </div>
        </div>
        {% endfor %}
    </div>
    {% else %}
    <div class="empty-state">
        <div class="empty-state-icon">
            <svg width="48" height="48" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
            </svg>
        </div>
        <h3 class="empty-state-title">No meetings yet</h3>
        <p class="empty-state-description">Start recording your first meeting to see it here</p>
        <a href="{{ url_for('pages.live') }}" class="btn btn-primary">Start Recording</a>
    </div>
    {% endif %}

    {% if user_tasks and user_tasks|length > 0 %}
    <div style="margin-top: var(--space-8);">
        <div class="section-header" style="animation-delay: 0.8s;">
            <h2 class="section-title">Your Tasks</h2>
            <a href="{{ url_for('dashboard.tasks') }}" class="section-link">
                View all
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                </svg>
            </a>
        </div>

        <div class="tasks-list">
            {% for task in user_tasks[:5] %}
            <div class="task-card">
                <div class="flex items-center gap-3">
                    <input type="checkbox" class="checkbox" {% if task.status == 'completed' %}checked{% endif %}>
                    <div class="flex-1">
                        <p class="font-medium {% if task.status == 'completed' %}text-tertiary{% endif %}">{{ task.description }}</p>
                        {% if task.meeting %}
                        <p class="text-tertiary text-xs mt-1">From: {{ task.meeting.title or 'Untitled Meeting' }}</p>
                        {% endif %}
                    </div>
                    {% if task.priority %}
                    <span class="badge badge-{% if task.priority == 'high' %}error{% elif task.priority == 'medium' %}warning{% else %}primary{% endif %}">
                        {{ task.priority }}
                    </span>
                    {% endif %}
                </div>
            </div>
            {% endfor %}
        </div>
    </div>
    {% endif %}
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/indexeddb-cache.js') }}"></script>
<script src="{{ url_for('static', filename='js/prefetch-controller.js') }}"></script>
<script src="{{ url_for('static', filename='js/broadcast-sync.js') }}"></script>
<script>
/**
 * CROWN‚Å¥ Cache Bootstrap - Load cached data instantly before server fetch
 * Achieves sub-200ms TTI with cache-first pattern + background reconciliation
 */
let dashboardCache = null;
let prefetchController = null;
const WORKSPACE_ID = {{ current_user.workspace_id if current_user.workspace_id else 1 }};

// Initialize PrefetchController
prefetchController = new PrefetchController({
    maxConcurrent: 3,
    maxCacheSize: 50,
    cacheTimeout: 60000 // 1 minute
});

// REMOVED: Legacy bootstrap function - using initializeDashboard() instead
// (This was causing duplicate initialization and race conditions)

/**
 * Morph Transition Handlers - Defined globally FIRST
 * Must be available before cache bootstrap runs
 */
const prefetchedSessions = new Set();

window.handleCardHover = function(event) {
    const card = event.currentTarget;
    const sessionId = card.dataset.sessionId;
    const meetingTitle = card.dataset.meetingTitle;
    
    // Skip if no session ID (meeting without linked session)
    if (!sessionId) {
        return;
    }
    
    // Skip if already prefetched
    if (prefetchedSessions.has(sessionId)) {
        return;
    }
    
    // Mark as prefetched
    prefetchedSessions.add(sessionId);
    
    console.log('üîÆ Prefetching session:', sessionId);
    
    // CROWN‚Å¥ Event #6: Log session_prefetch event to EventLedger (non-blocking)
    fetch('/dashboard/api/events/prefetch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            session_id: null,
            external_session_id: sessionId,
            meeting_id: card.dataset.meetingId
        })
    }).then(response => {
        if (response.ok) {
            return response.json();
        }
    }).then(result => {
        if (result) {
            console.log(`üîÆ Prefetch event logged (event_id=${result.event_id})`);
        }
    }).catch(err => {
        console.warn('‚ö†Ô∏è Failed to log prefetch event:', err);
    });
    
    // Broadcast session_prefetch event
    try {
        if (window.wsManager) {
            window.wsManager.emit('session_prefetch', {
                session_id: sessionId,
                meeting_title: meetingTitle,
                timestamp: Date.now()
            });
        }
    } catch (e) {
        console.warn('Failed to broadcast session_prefetch:', e);
    }
    
    // Prefetch session data via PrefetchController
    if (prefetchController) {
        prefetchController.prefetch(sessionId, { priority: 1 })
            .then(data => {
                if (data) {
                    try {
                        // Also cache in sessionStorage for compatibility
                        sessionStorage.setItem(`session_${sessionId}`, JSON.stringify({
                            data,
                            timestamp: Date.now()
                        }));
                        console.log('‚úÖ Session data prefetched and cached:', sessionId);
                    } catch (e) {
                        console.warn('Failed to cache session data:', e);
                    }
                }
            })
            .catch(err => {
                if (err.name !== 'AbortError') {
                    console.warn('Failed to prefetch session:', err);
                }
            });
    } else {
        console.warn('‚ö†Ô∏è PrefetchController not initialized');
    }
};

window.handleCardClick = function(event) {
    event.preventDefault();
    event.stopPropagation();
    
    const card = event.currentTarget;
    const meetingId = card.dataset.meetingId;
    const meetingTitle = card.dataset.meetingTitle;
    const sessionId = card.dataset.sessionId;
    
    console.log('üñ±Ô∏è Card clicked:', { meetingId, sessionId, meetingTitle });
    
    // If no session ID, show friendly message and skip
    if (!sessionId) {
        console.warn('‚ö†Ô∏è Meeting has no session ID, skipping navigation:', meetingId);
        
        // Show toast notification (if toast system exists)
        if (window.showToast) {
            window.showToast('This meeting is still being processed. Please try again in a moment.', 'info');
        }
        return;
    }
    
    // CRITICAL: Navigate immediately if GSAP not available (fallback)
    if (typeof gsap === 'undefined') {
        console.log('üîÑ GSAP not available, navigating directly');
        window.location.href = `/sessions/${sessionId}/refined`;
        return;
    }
    
    // CROWN‚Å¥ Optimization: Abort stale prefetches (user navigating to specific session)
    if (prefetchController) {
        // Get active requests and abort any that aren't for this session
        const stats = prefetchController.getStats();
        if (stats.activeRequests > 0) {
            // Abort all prefetches - user intent is clear now
            const aborted = prefetchController.abortAll();
            if (aborted > 0) {
                console.log(`üõë Aborted ${aborted} stale prefetches (user navigating to ${sessionId})`);
            }
        }
    }
    
    console.log('üé¨ Starting morph transition for session:', sessionId);
    
    // CROWN‚Å¥ Event #7: Log session_card_click event (non-blocking)
    fetch('/dashboard/api/events/card-click', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            session_id: null,
            external_session_id: sessionId,
            meeting_id: meetingId
        })
    }).then(response => {
        if (response.ok) {
            return response.json();
        }
    }).then(result => {
        if (result) {
            console.log(`üñ±Ô∏è Card click event logged (event_id=${result.event_id})`);
        }
    }).catch(err => {
        console.warn('‚ö†Ô∏è Failed to log card click event:', err);
    });
    
    // Create clone for animation
    const clone = card.cloneNode(true);
    const rect = card.getBoundingClientRect();
    
    // Style clone as fixed overlay
    Object.assign(clone.style, {
        position: 'fixed',
        top: `${rect.top}px`,
        left: `${rect.left}px`,
        width: `${rect.width}px`,
        height: `${rect.height}px`,
        margin: '0',
        zIndex: '9999',
        pointerEvents: 'none'
    });
    
    document.body.appendChild(clone);
    
    // Hide original card
    gsap.to(card, {
        opacity: 0,
        duration: 0.3
    });
    
    // Create overlay backdrop
    const overlay = document.createElement('div');
    Object.assign(overlay.style, {
        position: 'fixed',
        top: '0',
        left: '0',
        right: '0',
        bottom: '0',
        backgroundColor: 'rgba(0, 0, 0, 0)',
        zIndex: '9998',
        pointerEvents: 'none'
    });
    document.body.appendChild(overlay);
    
    // Animate backdrop fade in
    gsap.to(overlay, {
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        duration: 0.4
    });
    
    // Create loading overlay
    const loadingOverlay = document.createElement('div');
    Object.assign(loadingOverlay.style, {
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        textAlign: 'center',
        zIndex: '10000',
        pointerEvents: 'none',
        opacity: '0'
    });
    
    loadingOverlay.innerHTML = `
        <div style="
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            backdrop-filter: blur(20px);
            padding: 32px 48px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        ">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="
                animation: spin 1s linear infinite;
                margin-bottom: 16px;
            ">
                <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.3)" stroke-width="3"/>
                <path d="M12 2a10 10 0 0 1 10 10" stroke="white" stroke-width="3" stroke-linecap="round"/>
            </svg>
            <div style="
                color: white;
                font-size: 18px;
                font-weight: 600;
                margin-bottom: 8px;
                letter-spacing: -0.02em;
            ">${meetingTitle || 'Meeting'}</div>
            <div style="
                color: rgba(255, 255, 255, 0.85);
                font-size: 14px;
                font-weight: 500;
            ">Preparing insights...</div>
        </div>
        <style>
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
        </style>
    `;
    
    document.body.appendChild(loadingOverlay);
    
    // Fade in loading overlay
    gsap.to(loadingOverlay, {
        opacity: 1,
        duration: 0.3,
        delay: 0.2
    });
    
    // Calculate target dimensions
    const targetWidth = Math.min(window.innerWidth - 64, 1200);
    const targetHeight = window.innerHeight - 128;
    const targetLeft = (window.innerWidth - targetWidth) / 2;
    const targetTop = 64;
    
    // Cinematic morph animation with error handling
    try {
        const timeline = gsap.timeline({
            onComplete: () => {
                window.location.href = `/sessions/${sessionId}/refined`;
            }
        });
        
        timeline
            .to(clone, {
                top: targetTop,
                left: targetLeft,
                width: targetWidth,
                height: targetHeight,
                borderRadius: '24px',
                duration: 0.6,
                ease: 'power3.inOut'
            })
            .to(clone, {
                opacity: 0,
                duration: 0.2
            }, '-=0.1');
    } catch (animError) {
        console.warn('‚ö†Ô∏è Animation failed, navigating directly:', animError);
        window.location.href = `/sessions/${sessionId}/refined`;
    }
    
    // Store transition data
    try {
        sessionStorage.setItem('morphTransition', JSON.stringify({
            meetingId,
            meetingTitle,
            fromDashboard: true,
            timestamp: Date.now()
        }));
    } catch (e) {
        console.warn('Failed to store transition data:', e);
    }
};

window.initMorphTransitions = function() {
    console.log('üîç initMorphTransitions() called');
    const meetingCards = document.querySelectorAll('.meeting-card');
    console.log(`üîç Found ${meetingCards.length} meeting cards`);
    
    if (meetingCards.length === 0) {
        console.warn('‚ö†Ô∏è No meeting cards found to attach handlers!');
        return;
    }
    
    meetingCards.forEach((card, index) => {
        const sessionId = card.dataset.sessionId;
        const meetingId = card.dataset.meetingId;
        console.log(`üîç Card ${index}: meeting=${meetingId}, session=${sessionId}`);
        
        // Remove existing listeners to prevent duplicates
        card.removeEventListener('click', window.handleCardClick);
        card.removeEventListener('mouseenter', window.handleCardHover);
        
        // Add fresh listeners
        card.addEventListener('click', window.handleCardClick);
        card.addEventListener('mouseenter', window.handleCardHover);
        card.style.cursor = 'pointer';
    });
    
    console.log(`‚úÖ Initialized morph transitions for ${meetingCards.length} meeting cards`);
};

/**
 * Dashboard Real-time WebSocket Integration
 * CROWN‚Å¥ Event Handling for Live Updates
 */

(function() {
    'use strict';
    
    // Get workspace ID from user context
    const WORKSPACE_ID = {{ current_user.workspace_id }};
    
    // DOM elements - will be initialized after DOM ready
    let statElements = {
        totalMeetings: null,
        actionItems: null,
        hoursSaved: null
    };
    
    let meetingsListEl = null;
    let emptyStateEl = null;
    
    // Track bootstrap performance
    const bootstrapStart = performance.now();
    let cacheLoadTime = 0;
    let serverLoadTime = 0;
    
    /**
     * Initialize DOM references after DOM is ready
     * CRITICAL: Must be called after DOMContentLoaded to prevent null querySelector errors
     */
    function initDOMReferences() {
        // Safely query elements - may not exist on all dashboard states
        statElements = {
            totalMeetings: document.querySelector('.stat-card:nth-child(1) .stat-value'),
            actionItems: document.querySelector('.stat-card:nth-child(2) .stat-value'),
            hoursSaved: document.querySelector('.stat-card:nth-child(3) .stat-value')
        };
        
        meetingsListEl = document.querySelector('.meetings-list');
        emptyStateEl = document.querySelector('.empty-state');
        
        console.log('üìç DOM references initialized:', {
            totalMeetings: !!statElements.totalMeetings,
            actionItems: !!statElements.actionItems,
            hoursSaved: !!statElements.hoursSaved,
            meetingsListEl: !!meetingsListEl,
            emptyStateEl: !!emptyStateEl
        });
        
        // CRITICAL: Initialize meeting card click handlers immediately
        // This ensures cards are clickable even if stats don't exist
        if (window.initMorphTransitions) {
            window.initMorphTransitions();
            console.log('‚úÖ Meeting card click handlers initialized');
        } else {
            console.warn('‚ö†Ô∏è initMorphTransitions not available');
        }
    }
    
    /**
     * Bootstrap dashboard with cache-first strategy
     * CROWN‚Å¥ requirement: Load from IndexedDB in <200ms, then sync with server
     */
    async function bootstrapDashboard() {
        console.log('‚ö° Starting dashboard bootstrap...');
        
        try {
            // Initialize cache manager
            await window.cacheManager.init();
            
            // ALWAYS load from cache first (even if stale) for instant TTI
            console.log('üíæ Loading from cache (stale-acceptable)...');
            const cacheStart = performance.now();
            
            // Load from cache in parallel
            const [cachedMeetings, cachedAnalytics] = await Promise.all([
                window.cacheManager.getCachedMeetings(WORKSPACE_ID),
                window.cacheManager.getCachedAnalytics(WORKSPACE_ID)
            ]);
            
            cacheLoadTime = Math.round(performance.now() - cacheStart);
            
            // Render cached data immediately (even if stale)
            let cacheHit = false;
            if (cachedMeetings && cachedMeetings.length > 0) {
                renderCachedMeetings(cachedMeetings.slice(0, 5));
                cacheHit = true;
            }
            
            if (cachedAnalytics && cachedAnalytics.data) {
                updateStatsFromCache(cachedAnalytics.data);
                cacheHit = true;
            }
            
            if (cacheHit) {
                const totalBootstrapTime = Math.round(performance.now() - bootstrapStart);
                console.log(`üöÄ Dashboard rendered from cache in ${totalBootstrapTime}ms`);
                
                if (totalBootstrapTime > 200) {
                    console.warn(`‚ö†Ô∏è Cache load exceeded 200ms target: ${totalBootstrapTime}ms`);
                } else {
                    console.log(`‚úÖ Sub-200ms TTI achieved! (${totalBootstrapTime}ms)`);
                }
            } else {
                console.log('‚è≥ No cache available, using server-rendered data');
            }
            
            // Log dashboard_bootstrap event to EventLedger (CROWN‚Å¥ Event #1)
            try {
                const totalBootstrapTime = Math.round(performance.now() - bootstrapStart);
                const response = await fetch('/dashboard/api/events/bootstrap', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        cache_load_time: cacheLoadTime,
                        server_load_time: serverLoadTime,
                        total_time: totalBootstrapTime,
                        cache_hit: cacheHit
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log(`üìä dashboard_bootstrap event logged (event_id=${result.event_id}, sub_200ms=${result.sub_200ms})`);
                } else {
                    console.warn('‚ö†Ô∏è Failed to log dashboard_bootstrap event:', response.status);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to log dashboard_bootstrap event:', error);
                // Non-blocking - continue even if event logging fails
            }
            
            // Always sync with server in background (validate even if fresh)
            syncWithServer();
            
            // Initialize morph transitions for all cards (server-rendered + cache-rendered)
            // This ensures event listeners are attached regardless of card source
            console.log('üéØ Attaching event listeners to all meeting cards...');
            if (window.initMorphTransitions) {
                window.initMorphTransitions();
            } else {
                console.error('‚ùå initMorphTransitions not available!');
            }
            
        } catch (error) {
            console.error('‚ùå Bootstrap failed:', error);
            // Graceful degradation: page will use server-rendered data
            // Still try to attach event listeners to server-rendered cards
            if (window.initMorphTransitions) {
                window.initMorphTransitions();
            }
        }
    }
    
    /**
     * Render cached meetings to the DOM
     * @param {Array} meetings - Cached meeting records
     */
    function renderCachedMeetings(meetings) {
        if (!meetingsListEl || meetings.length === 0) return;
        
        // Clear existing content
        meetingsListEl.innerHTML = '';
        
        // Hide empty state
        if (emptyStateEl) {
            emptyStateEl.style.display = 'none';
        }
        
        // Render each meeting
        meetings.forEach((meeting, index) => {
            const sessionId = meeting.session_id || meeting.external_id || null;
            const cardHTML = `
                <div class="meeting-card" 
                     data-meeting-id="${meeting.id}" 
                     data-meeting-title="${escapeHtml(meeting.title || 'Untitled Meeting')}"
                     ${sessionId ? `data-session-id="${sessionId}"` : ''}
                     style="animation: fadeInUp 0.4s ease-out ${index * 0.1}s both;">
                    <div class="flex justify-between items-start">
                        <div class="flex-1">
                            <h3 class="meeting-title">${escapeHtml(meeting.title || 'Untitled Meeting')}</h3>
                            <p class="meeting-date">${formatDate(meeting.created_at)}</p>
                            ${meeting.summary ? `<p class="meeting-summary">${escapeHtml(meeting.summary.substring(0, 150))}${meeting.summary.length > 150 ? '...' : ''}</p>` : ''}
                        </div>
                        <div class="flex items-center gap-3">
                            ${meeting.duration ? `<span class="badge badge-primary">${Math.round(meeting.duration / 60)} min</span>` : ''}
                            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="opacity: 0.5;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                            </svg>
                        </div>
                    </div>
                </div>
            `;
            
            meetingsListEl.insertAdjacentHTML('beforeend', cardHTML);
        });
        
        // Initialize morph transitions for newly rendered cards
        if (window.initMorphTransitions) {
            window.initMorphTransitions();
        }
    }
    
    /**
     * Update statistics from cached data
     * @param {Object} data - Cached analytics data
     */
    function updateStatsFromCache(data) {
        if (!data) return;
        
        if (data.total_meetings !== undefined && statElements.totalMeetings) {
            statElements.totalMeetings.textContent = data.total_meetings;
        }
        if (data.total_tasks !== undefined && statElements.actionItems) {
            statElements.actionItems.textContent = data.total_tasks;
        }
        if (data.hours_saved !== undefined && statElements.hoursSaved) {
            statElements.hoursSaved.textContent = data.hours_saved;
        }
    }
    
    /**
     * Sync with server in background and validate cache
     */
    async function syncWithServer() {
        console.log('üîÑ Starting background server sync...');
        const serverStart = performance.now();
        
        try {
            // Fetch fresh data from server (use existing stats from page)
            const serverStats = {
                total_meetings: {{ stats.total_meetings|default(0) }},
                total_tasks: {{ stats.total_tasks|default(0) }},
                hours_saved: {{ stats.get('hours_saved', 0) }}
            };
            
            // Get cached data for validation
            const [cachedMeetings, cachedAnalytics] = await Promise.all([
                window.cacheManager.getCachedMeetings(WORKSPACE_ID),
                window.cacheManager.getCachedAnalytics(WORKSPACE_ID)
            ]);
            
            // Validate analytics
            if (cachedAnalytics) {
                const validation = await window.cacheValidator.validate({
                    cachedData: cachedAnalytics.data,
                    serverData: serverStats,
                    key: `analytics_${WORKSPACE_ID}`
                });
                
                if (validation.drift) {
                    console.log('‚ö†Ô∏è Analytics drift detected, updating from server');
                    updateStatsFromCache(serverStats);
                    await window.cacheManager.cacheAnalyticsSnapshot(serverStats, WORKSPACE_ID);
                }
            } else {
                // No cache, store server data
                await window.cacheManager.cacheAnalyticsSnapshot(serverStats, WORKSPACE_ID);
            }
            
            serverLoadTime = Math.round(performance.now() - serverStart);
            console.log(`‚úÖ Server sync complete in ${serverLoadTime}ms`);
            
        } catch (error) {
            console.error('‚ùå Server sync failed:', error);
        }
    }
    
    /**
     * Start idle sync timer for background validation
     * Runs checksum validation every 30 seconds
     */
    function startIdleSync() {
        console.log('‚è∞ Starting idle sync timer (30s interval)...');
        
        setInterval(async () => {
            try {
                await performIdleSync();
            } catch (error) {
                console.error('‚ùå Idle sync failed:', error);
            }
        }, 30000); // 30 seconds
    }
    
    /**
     * Perform idle sync validation
     * Check cache freshness and sync if needed
     */
    async function performIdleSync() {
        console.log('üîç Running idle sync validation...');
        const syncStart = performance.now();
        
        try {
            // Get current server stats from DOM
            const serverStats = {
                total_meetings: parseInt(statElements.totalMeetings?.textContent || '0'),
                total_tasks: parseInt(statElements.actionItems?.textContent || '0'),
                hours_saved: parseInt(statElements.hoursSaved?.textContent || '0')
            };
            
            // Get cached analytics
            const cachedAnalytics = await window.cacheManager.getCachedAnalytics(WORKSPACE_ID);
            
            if (!cachedAnalytics) {
                console.log('üíæ No cache found, caching current state...');
                await window.cacheManager.cacheAnalyticsSnapshot(serverStats, WORKSPACE_ID);
                return;
            }
            
            // Validate cache against current state
            const validation = await window.cacheValidator.validate({
                cachedData: cachedAnalytics.data,
                serverData: serverStats,
                key: `analytics_${WORKSPACE_ID}`
            });
            
            if (validation.drift) {
                console.warn('‚ö†Ô∏è Cache drift detected during idle sync');
                
                // Calculate delta
                const cachedData = cachedAnalytics.data;
                const changes = [];
                
                if (cachedData.total_meetings !== serverStats.total_meetings) {
                    changes.push(`meetings: ${cachedData.total_meetings} ‚Üí ${serverStats.total_meetings}`);
                }
                if (cachedData.total_tasks !== serverStats.total_tasks) {
                    changes.push(`tasks: ${cachedData.total_tasks} ‚Üí ${serverStats.total_tasks}`);
                }
                if (cachedData.hours_saved !== serverStats.hours_saved) {
                    changes.push(`hours: ${cachedData.hours_saved} ‚Üí ${serverStats.hours_saved}`);
                }
                
                console.log('üìä Changes detected:', changes.join(', '));
                
                // Update cache with current state
                await window.cacheManager.cacheAnalyticsSnapshot(serverStats, WORKSPACE_ID);
                console.log('üíæ Cache synchronized');
            } else {
                console.log('‚úÖ Cache valid, no sync needed');
            }
            
            const syncTime = Math.round(performance.now() - syncStart);
            console.log(`‚è±Ô∏è Idle sync completed in ${syncTime}ms`);
            
        } catch (error) {
            console.error('‚ùå Idle sync error:', error);
        }
    }
    
    /**
     * Initialize WebSocket connection
     */
    function initWebSocket() {
        console.log('üöÄ Initializing dashboard WebSocket...');
        
        // Initialize WebSocket manager with dashboard namespace
        window.wsManager.init(WORKSPACE_ID, ['dashboard']);
        
        // Listen for connection status changes
        window.wsManager.on('connection_status', (data) => {
            if (data.connected && data.namespace === 'dashboard') {
                console.log('‚úÖ Dashboard connected to real-time updates');
                showConnectionStatus('connected');
            } else {
                console.warn('‚ö†Ô∏è Dashboard disconnected from real-time updates');
                showConnectionStatus('disconnected');
            }
        });
        
        // Listen for session_update:created events
        window.wsManager.on('session_update:created', handleNewSession);
        
        // Listen for dashboard_refresh events
        window.wsManager.on('dashboard_refresh', handleDashboardRefresh);
        
        // Listen for task_update events (for action items counter)
        window.wsManager.on('task_update', handleTaskUpdate);
        
        console.log('üì° Dashboard WebSocket listeners registered');
    }
    
    /**
     * Handle new session created event
     * @param {Object} data - Event data containing session/meeting info
     */
    function handleNewSession(data) {
        console.log('üì¨ New session created event received:', data);
        
        // Safety check: Ensure DOM is ready before accessing elements
        if (!statElements) {
            console.warn('‚ö†Ô∏è statElements not initialized yet, deferring handleNewSession');
            // Defer execution until DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => handleNewSession(data), { once: true });
            }
            return;
        }
        
        const sessionData = data.data || data;
        
        // Update total meetings counter with animation
        updateCounter(statElements.totalMeetings, 1, 'increment');
        
        // Insert new meeting card at top of list
        insertMeetingCard(sessionData);
        
        // Remove empty state if present
        if (emptyStateEl) {
            emptyStateEl.style.opacity = '0';
            setTimeout(() => {
                emptyStateEl.style.display = 'none';
            }, 300);
        }
        
        // Show notification
        showNotification('New meeting recorded', 'A new meeting has been added to your dashboard');
    }
    
    /**
     * Handle dashboard refresh event
     * @param {Object} data - Event data with updated statistics
     */
    async function handleDashboardRefresh(data) {
        console.log('üîÑ Dashboard refresh event received:', data);
        
        // Safety check: Ensure DOM is ready before accessing elements
        if (!statElements) {
            console.warn('‚ö†Ô∏è statElements not initialized yet, deferring handleDashboardRefresh');
            // Defer execution until DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => handleDashboardRefresh(data), { once: true });
            }
            return;
        }
        
        const stats = data.data || data;
        
        // Update all counters
        if (stats.total_meetings !== undefined) {
            updateCounter(statElements.totalMeetings, stats.total_meetings, 'set');
        }
        if (stats.total_tasks !== undefined) {
            updateCounter(statElements.actionItems, stats.total_tasks, 'set');
        }
        if (stats.hours_saved !== undefined) {
            updateCounter(statElements.hoursSaved, stats.hours_saved, 'set');
        }
        
        // Update cache with fresh statistics
        try {
            await window.cacheManager.cacheAnalyticsSnapshot(stats, WORKSPACE_ID);
            console.log('üíæ Cache updated with fresh analytics');
        } catch (error) {
            console.error('‚ùå Failed to update cache:', error);
        }
    }
    
    /**
     * Handle task update event
     * @param {Object} data - Event data with task information
     */
    function handleTaskUpdate(data) {
        console.log('‚úÖ Task update event received:', data);
        
        // Safety check: Ensure DOM is ready before accessing elements
        if (!statElements) {
            console.warn('‚ö†Ô∏è statElements not initialized yet, deferring handleTaskUpdate');
            // Defer execution until DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => handleTaskUpdate(data), { once: true });
            }
            return;
        }
        
        const taskData = data.data || data;
        
        // Update action items counter based on task action
        if (taskData.action === 'created') {
            updateCounter(statElements.actionItems, 1, 'increment');
        } else if (taskData.action === 'deleted') {
            updateCounter(statElements.actionItems, -1, 'increment');
        }
    }
    
    /**
     * Update counter with animation
     * @param {HTMLElement} element - Counter element
     * @param {number} value - New value or increment/decrement amount
     * @param {string} mode - 'set', 'increment', or 'decrement'
     */
    function updateCounter(element, value, mode = 'set') {
        if (!element) {
            console.warn('‚ö†Ô∏è updateCounter called with null element, skipping');
            return;
        }
        
        const currentValue = parseInt(element.textContent) || 0;
        let newValue;
        
        if (mode === 'set') {
            newValue = value;
        } else if (mode === 'increment') {
            newValue = currentValue + value;
        } else if (mode === 'decrement') {
            newValue = currentValue - value;
        }
        
        // Add shimmer animation
        element.parentElement.parentElement.classList.add('stat-card-shimmer');
        
        // Animate counter change
        animateCounter(element, currentValue, newValue, 500);
        
        // Remove shimmer after animation
        setTimeout(() => {
            element.parentElement.parentElement.classList.remove('stat-card-shimmer');
        }, 1000);
    }
    
    /**
     * Animate counter from current to new value
     * @param {HTMLElement} element - Counter element
     * @param {number} start - Start value
     * @param {number} end - End value
     * @param {number} duration - Animation duration in ms
     */
    function animateCounter(element, start, end, duration) {
        const startTime = Date.now();
        const difference = end - start;
        
        function update() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Easing function (ease-out cubic)
            const eased = 1 - Math.pow(1 - progress, 3);
            const current = Math.round(start + (difference * eased));
            
            element.textContent = current;
            
            if (progress < 1) {
                requestAnimationFrame(update);
            }
        }
        
        update();
    }
    
    /**
     * Insert new meeting card at top of list
     * @param {Object} meetingData - Meeting data from event
     */
    function insertMeetingCard(meetingData) {
        if (!meetingsListEl) {
            // If meetings list doesn't exist, create it
            createMeetingsList();
            
            // If still null after creation attempt, bail out
            if (!meetingsListEl) {
                console.warn('‚ö†Ô∏è Cannot insert meeting card: meetings list element not found');
                return;
            }
        }
        
        const meeting = meetingData.meeting || meetingData;
        
        // Create meeting card HTML (with session ID support for morph transitions)
        const sessionId = meeting.session_id || meeting.external_id || null;
        const cardHTML = `
            <div class="meeting-card new-card" 
                 data-meeting-id="${meeting.id}" 
                 data-meeting-title="${escapeHtml(meeting.title || 'Untitled Meeting')}"
                 ${sessionId ? `data-session-id="${sessionId}"` : ''}
                 style="animation: bounceIn 0.6s ease-out;">
                <div class="flex justify-between items-start">
                    <div class="flex-1">
                        <h3 class="meeting-title">${escapeHtml(meeting.title || 'Untitled Meeting')}</h3>
                        <p class="meeting-date">${formatDate(meeting.created_at || new Date())}</p>
                        ${meeting.summary ? `<p class="meeting-summary">${escapeHtml(meeting.summary.substring(0, 150))}${meeting.summary.length > 150 ? '...' : ''}</p>` : ''}
                    </div>
                    <div class="flex items-center gap-3">
                        <span class="badge badge-success" style="animation: pulseGlow 1.5s ease-in-out 3;">‚ú® New</span>
                        ${meeting.duration ? `<span class="badge badge-primary">${Math.round(meeting.duration / 60)} min</span>` : ''}
                        <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="opacity: 0.5;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                        </svg>
                    </div>
                </div>
            </div>
        `;
        
        // Insert at top of list
        meetingsListEl.insertAdjacentHTML('afterbegin', cardHTML);
        
        // Initialize morph transitions for all cards (including the new one)
        if (window.initMorphTransitions) {
            window.initMorphTransitions();
        }
        
        // Get the newly inserted card for additional styling
        try {
            const newCard = meetingsListEl.querySelector('.new-card');
            if (newCard) {
                // Apply pulse glow animation to the entire card
                newCard.style.animation += ', pulseGlow 2s ease-in-out 2';
                
                // Remove new badge after 5 seconds
                setTimeout(() => {
                    const newBadge = newCard.querySelector('.badge-success');
                    if (newBadge) {
                        newBadge.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        newBadge.style.opacity = '0';
                        newBadge.style.transform = 'scale(0.8)';
                        setTimeout(() => newBadge.remove(), 300);
                    }
                }, 5000);
                
                // Remove new-card class after animation
                setTimeout(() => {
                    newCard.classList.remove('new-card');
                }, 600);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Failed to style new card:', error);
        }
    }
    
    /**
     * Create meetings list if it doesn't exist
     */
    function createMeetingsList() {
        try {
            const container = document.querySelector('.dashboard-container');
            const sectionHeader = document.querySelector('.section-header');
            
            if (sectionHeader && !meetingsListEl) {
                const listHTML = '<div class="meetings-list"></div>';
                sectionHeader.insertAdjacentHTML('afterend', listHTML);
                // Update reference
                meetingsListEl = document.querySelector('.meetings-list');
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Failed to create meetings list:', error);
        }
    }
    
    /**
     * Show connection status indicator
     * @param {string} status - 'connected' or 'disconnected'
     */
    function showConnectionStatus(status) {
        // Add visual indicator in navbar or corner
        const indicator = document.createElement('div');
        indicator.className = `connection-indicator ${status}`;
        indicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
            ${status === 'connected' ? 'background: #10b981; color: white;' : 'background: #ef4444; color: white;'}
        `;
        indicator.textContent = status === 'connected' ? 'üü¢ Live' : 'üî¥ Offline';
        
        document.body.appendChild(indicator);
        
        // Auto-remove after 3 seconds
        setTimeout(() => {
            indicator.style.opacity = '0';
            setTimeout(() => indicator.remove(), 300);
        }, 3000);
    }
    
    /**
     * Show notification toast
     * @param {string} title - Notification title
     * @param {string} message - Notification message
     */
    function showNotification(title, message) {
        const notification = document.createElement('div');
        notification.className = 'notification-toast';
        notification.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            max-width: 400px;
            padding: 16px;
            background: var(--glass-bg);
            backdrop-filter: var(--backdrop-blur);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-xl);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            animation: slideInFromRight 0.3s ease-out;
        `;
        
        notification.innerHTML = `
            <div style="display: flex; gap: 12px; align-items: start;">
                <div style="flex-shrink: 0; width: 40px; height: 40px; background: var(--gradient-primary); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                    <svg width="20" height="20" fill="white" viewBox="0 0 24 24">
                        <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                </div>
                <div style="flex: 1;">
                    <p style="font-weight: 600; margin-bottom: 4px;">${escapeHtml(title)}</p>
                    <p style="font-size: 14px; color: var(--color-text-secondary);">${escapeHtml(message)}</p>
                </div>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            notification.style.animation = 'slideOutToRight 0.3s ease-out';
            setTimeout(() => notification.remove(), 300);
        }, 5000);
    }
    
    /**
     * Format date to readable string
     * @param {string|Date} date - Date to format
     * @returns {string} Formatted date string
     */
    function formatDate(date) {
        const d = new Date(date);
        return d.toLocaleString('en-US', { 
            month: 'long', 
            day: 'numeric', 
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
        });
    }
    
    /**
     * Escape HTML to prevent XSS
     * @param {string} text - Text to escape
     * @returns {string} Escaped text
     */
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // REMOVED: Duplicate initialization - using initializeDashboard() below instead
    
    // Add CSS for new animations
    const style = document.createElement('style');
    style.textContent = `
        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes slideOutToRight {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(20px);
            }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes pulseGlow {
            0% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 20px 8px rgba(139, 92, 246, 0.3);
                transform: scale(1.02);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0);
                transform: scale(1);
            }
        }
        
        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3) translateY(-50px);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.95);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes shimmer {
            0% {
                background-position: -200% center;
            }
            100% {
                background-position: 200% center;
            }
        }
        
        .stat-card-shimmer::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            background-size: 200% 100%;
            animation: shimmer 1s ease-in-out;
            pointer-events: none;
        }
        
        /* Enhanced hover effects for meeting cards */
        .meeting-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .meeting-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }
        
        /* Smooth transitions for stat cards */
        .stat-card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
        }
        
        /* Loading skeleton pulse */
        @keyframes skeletonPulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        .skeleton {
            animation: skeletonPulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            background: linear-gradient(90deg, 
                var(--glass-bg) 0%, 
                rgba(255, 255, 255, 0.1) 50%, 
                var(--glass-bg) 100%
            );
            background-size: 200% 100%;
        }
    `;
    document.head.appendChild(style);
    
    /**
     * Initialize Dashboard - CROWN‚Å¥ Event Sequencing Entry Point
     * Event #1: dashboard_bootstrap
     */
    function initializeDashboard() {
        console.log('üåü CROWN‚Å¥ Dashboard Initialization Starting...');
        console.log('üìã Event Sequence: dashboard_bootstrap ‚Üí session_prefetch ‚Üí session_card_click');
        
        // Step 0: Initialize DOM references FIRST (prevent querySelector errors)
        initDOMReferences();
        
        // Step 1: Bootstrap cache-first rendering
        bootstrapDashboard()
            .then(() => {
                console.log('‚úÖ Bootstrap complete - cache loaded, cards rendered, listeners attached');
                
                // Step 2: Initialize WebSocket for real-time updates (Event #2: session_update:created)
                console.log('üîå Initializing WebSocket connection...');
                initWebSocket();
                
                // Step 3: Start background idle sync (Event #13: dashboard_idle_sync)
                console.log('‚è∞ Starting idle sync timer...');
                startIdleSync();
                
                console.log('üéâ CROWN‚Å¥ Dashboard fully initialized - ready for user interaction!');
            })
            .catch(error => {
                console.error('‚ùå Dashboard initialization failed:', error);
                // Fallback: still try to initialize WebSocket and sync
                initWebSocket();
                startIdleSync();
            });
    }
    
    // Trigger initialization when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeDashboard);
    } else {
        // DOM already loaded, execute immediately
        initializeDashboard();
    }
    
})();
</script>

<script src="{{ url_for('static', filename='js/mobile-gestures.js') }}"></script>
<!-- CRITICAL: Simple card click handler loaded LAST to ensure it works -->
<script src="{{ url_for('static', filename='js/dashboard-card-clicks.js') }}"></script>
{% endblock %}
