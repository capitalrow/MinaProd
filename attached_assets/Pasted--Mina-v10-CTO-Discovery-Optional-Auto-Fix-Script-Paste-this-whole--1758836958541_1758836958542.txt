# -------------------------
# Mina v10: CTO Discovery + Optional Auto-Fix Script
# Paste this whole block to your Replit Agent / shell.
# Mode: set MODE=inspect  OR  MODE=autofix
# -------------------------

MODE=${MODE:-inspect}   # change to "autofix" to allow safe auto-patching

set -euo pipefail
export LANG=C.UTF-8

echo "== START MINA V10 DISCOVERY (MODE=$MODE) =="

# 1) Ensure workspace listed and MinaInsight zip presence
echo
echo "-> Present working directory: $(pwd)"
echo "-> Checking for MinaInsight zip files..."
ls -la MinaInsight* || true

# 2) If a MinaInsight*.zip exists and repo not yet unzipped, unzip safely into ./mina_unpacked
ZIP=$(ls -1 MinaInsight*.zip 2>/dev/null | head -n 1 || true)
if [ -n "$ZIP" ]; then
  echo "-> Found zip: $ZIP"
  mkdir -p mina_unpacked
  echo "-> Unzipping into ./mina_unpacked (non-destructive)"
  unzip -o "$ZIP" -d mina_unpacked || true
  echo "-> Done. Listing ./mina_unpacked (depth 3):"
  if command -v tree >/dev/null 2>&1; then
    tree -L 3 mina_unpacked || true
  else
    find mina_unpacked -maxdepth 3 -print | sed 's/^/ /'
  fi
else
  echo "-> No MinaInsight zip detected in workspace (or it's been moved)."
fi

# 3) Repo tree (depth 3)
echo
echo "=== REPO TREE (depth 3) ==="
if command -v tree >/dev/null 2>&1; then
  tree -L 3 || true
else
  find . -maxdepth 3 -print | sed 's/^/ /' || true
fi

# 4) Files to inspect (tolerate missing)
FILES=(
  app.py
  server/__init__.py
  server/auth.py
  server/api.py
  server/models.py
  server/uploads.py
  server/websocket.py
  server/socketio_server.py
  static/ui/index.html
  static/ui/welcome.html
  static/ui/share.html
  static/js/mina.api.js
  static/js/mina.socket.js
  requirements.txt
  .env
)

echo
echo "=== DUMPING FILES (first 400 lines each; MISSING marked) ==="
for f in "${FILES[@]}"; do
  echo
  echo "----- FILE: $f -----"
  if [ -f "$f" ]; then
    sed -n '1,400p' "$f"
    if [ $(wc -l < "$f") -gt 400 ]; then
      echo "... (file longer than 400 lines; only first 400 shown) ..."
    fi
  else
    echo "MISSING: $f"
  fi
done

# 5) Grep for socket/openai/proxies clues
echo
echo "=== SEARCH: Socket.IO emits / handlers / event names ==="
grep -R --line-number -nE "emit\\(|socket\\.on\\(|io\\(|on\\(|emit\\(" . || true

echo
echo "=== SEARCH: OpenAI / Client / proxies / whisper / transcribe occurrences ==="
grep -R --line-number -nE "openai|OpenAI|Client\\(|proxies|whisper|transcribe|transcription" . || true

# 6) requirements and python env
echo
echo "=== Python packages installed (pip freeze top 200) ==="
python3 -m pip freeze | sed -n '1,200p' || true

# 7) Try to detect and print socket server file quickly
echo
echo "=== TRYING TO LOCATE SOCKET.IO SERVER FILES ==="
grep -R --line-number -nE "SocketIO\\(|socketio\\.|from socketio|import socketio|socketio\\." . || true

# 8) Create safe backup dir for any changes (only if MODE=autofix)
BACKUP_DIR=".mina_backups_$(date +%Y%m%d_%H%M%S)"
if [ "$MODE" = "autofix" ]; then
  echo
  echo "-> AUTO-FIX MODE: Creating backup dir $BACKUP_DIR"
  mkdir -p "$BACKUP_DIR"
fi

# 9) Basic server smoke test: try to start the server (if app.py exists)
echo
echo "=== QUICK SERVER SMOKE TEST ==="
if [ -f "app.py" ]; then
  echo "-> app.py found. Attempting to run 'python3 app.py' in background for 8s (logs -> /tmp/mina_server.log)."
  nohup python3 app.py > /tmp/mina_server.log 2>&1 & sleep 8 || true
  echo "--- tail /tmp/mina_server.log (last 120 lines) ---"
  tail -n 120 /tmp/mina_server.log || true
  echo "--- Checking health endpoints (localhost:8080) ---"
  curl -I --max-time 4 http://localhost:8080/healthz 2>/dev/null || echo "healthz request failed"
  curl -I --max-time 4 http://localhost:8080/readyz 2>/dev/null || echo "readyz request failed"
else
  echo "-> app.py not found at repo root; skipping smoke start. If your server entrypoint is different, please tell me or ensure the file is listed above."
fi

# 10) If MODE=autofix, apply safe, non-destructive patches:
if [ "$MODE" = "autofix" ]; then
  echo
  echo "=== AUTO-FIX: Running safe fixes (backups created) ==="

  # 10a) Fix potential OpenAI Client proxy kwarg issue:
  # Find files that initialize a Client(...) with a proxies keyword and create a patched copy.
  echo "-> Searching for 'Client(' with 'proxies' keyword usage..."
  PROXY_OCCURRENCES=$(grep -R --line-number -n "Client(.*proxies" || true)
  if [ -n "$PROXY_OCCURRENCES" ]; then
    echo "-> Found candidate lines with proxies usage:"
    echo "$PROXY_OCCURRENCES"
    # For each file with proxies, create backup and patch: remove proxies kwarg when constructing Client(...)
    echo "$PROXY_OCCURRENCES" | cut -d: -f1 | sort -u | while read -r file; do
      echo "  - Backing up $file -> $BACKUP_DIR/"
      cp "$file" "$BACKUP_DIR/"
      # Create a patched version: remove occurrences of "proxies=..." inside Client(...)
      python3 - "$file" > "$file.tmp" <<'PYCODE'
import sys,re
p=sys.argv[1]
s=open(p,'r',encoding='utf-8').read()
# This removes simple "proxies=..." kwargs inside Client(...) calls (best-effort)
s2=re.sub(r'(Client\\()([^\\)]*?)\\bproxies\\s*=\\s*[^,\\)]+(,?)', r'\\1\\2\\3', s, flags=re.S)
open(p+'.tmp','w',encoding='utf-8').write(s2)
PYCODE
      mv "$file.tmp" "$file"
      echo "  - Patched $file (proxies removed if present)."
    done
  else
    echo "-> No 'proxies' usage with Client(...) found."
  fi

  # 10b) Add robust client-side mina.socket.js (if missing or to replace)
  if [ ! -d "static/js" ]; then mkdir -p static/js; fi
  SOCKET_BRIDGE="static/js/mina.socket.js"
  echo "-> Installing robust client-side socket bridge -> $SOCKET_BRIDGE (backup if exists)"
  if [ -f "$SOCKET_BRIDGE" ]; then cp "$SOCKET_BRIDGE" "$BACKUP_DIR/"; fi
  cat > "$SOCKET_BRIDGE" <<'JSSCR'
/* Robust MinaSocket bridge (auto-detects event names; ordered; light backpressure).
   Drop-in replacement for static/js/mina.socket.js */
window.MinaSocket = (function(){
  const EVENT_NAMES = {
    interim: ["transcription:interim","interim","partial","whisper:interim","stt:interim"],
    final:   ["transcription:final","final","complete","whisper:final","stt:final"],
    error:   ["transcription:error","error","stt:error"],
    hello:   ["server_hello","hello","welcome"]
  };
  let socket, convId, nextIdx = 0;
  let onInterimCB, onFinalCB, onErrorCB;
  const maxPending = 8; let pending = 0;
  function normalizeHandler(handler){
    return (payload) => {
      try {
        const text = payload && payload.text ? String(payload.text) : "";
        const start_ms = Number((payload && payload.start_ms) || 0);
        const end_ms = Number((payload && payload.end_ms) || 0);
        handler({ text, start_ms, end_ms, raw: payload });
      } catch(e) { console.error("[mina] normalize failed", e); }
    };
  }
  function connect(options){
    socket = (typeof io !== 'undefined') ? (options && options.baseUrl ? io(options.baseUrl,{transports:['websocket','polling']}) : io({transports:['websocket','polling']})) : null;
    if(!socket){ console.warn("[mina] socket.io not found on page"); return; }
    socket.on("connect", ()=>console.log("[mina] socket connected", socket.id));
    socket.on("disconnect", (r)=>console.log("[mina] socket disconnected", r));
    EVENT_NAMES.hello.forEach(ev=>socket.on(ev,msg=>console.log("[mina] hello",ev,msg)));
    EVENT_NAMES.error.forEach(ev=>socket.on(ev,err=>{ console.error("[mina] error",ev,err); onErrorCB && onErrorCB(err); }));
    const interimHandler = normalizeHandler(async ({text,start_ms,end_ms})=>{
      if(!convId||!text) return;
      if(pending>=maxPending) return;
      pending++;
      try{
        await API.conv.addSegment(convId, { idx: nextIdx++, start_ms, end_ms, text, is_final:false });
        onInterimCB && onInterimCB({text,start_ms,end_ms});
      }catch(e){ console.error("[mina] persist interim failed", e); }
      finally{ pending--; }
    });
    const finalHandler = normalizeHandler(async ({text,start_ms,end_ms})=>{
      if(!convId||!text) return;
      pending++;
      try{
        await API.conv.addSegment(convId, { idx: nextIdx++, start_ms, end_ms, text, is_final:true });
        onFinalCB && onFinalCB({text,start_ms,end_ms});
      }catch(e){ console.error("[mina] persist final failed", e); }
      finally{ pending--; }
    });
    EVENT_NAMES.interim.forEach(ev=>socket.on(ev,interimHandler));
    EVENT_NAMES.final.forEach(ev=>socket.on(ev,finalHandler));
  }
  async function startSession(title="Untitled Conversation"){ const r=await API.conv.create(title); convId=r.id; nextIdx=0; return convId; }
  async function stopSession(){ if(!convId) return; let i=0; while(pending>0&&i<50){ await new Promise(r=>setTimeout(r,60)); i++; } await API.conv.finalize(convId); const done=convId; convId=null; nextIdx=0; return done; }
  return { connect, startSession, stopSession, onInterim(cb){onInterimCB=cb;}, onFinal(cb){onFinalCB=cb;}, onError(cb){onErrorCB=cb;} };
})();
JSSCR
  echo "-> Wrote $SOCKET_BRIDGE"

  # 10c) Search server-side socket file(s) and add light backpressure guard (only if we find emit handlers)
  SOCKET_FILES=$(grep -R --line-number -nE "emit\\(|broadcast\\.|send\\(|socket\\.emit\\(|socket\\.on\\(" . | cut -d: -f1 | sort -u || true)
  if [ -n "$SOCKET_FILES" ]; then
    echo "-> Found socket-related files:"
    echo "$SOCKET_FILES"
    echo "$SOCKET_FILES" | while read -r sf; do
      echo "  - Backing up $sf -> $BACKUP_DIR/"
      cp "$sf" "$BACKUP_DIR/"
      # best-effort: insert a simple in-file comment warning and leave content unchanged (automatic edits may break custom logic).
      sed -n '1,200p' "$sf" > "$sf.auto_patch_preview"
      echo -e "\n# AUTO PATCH PREVIEW (manual verification recommended) - Mina v10\n# Added: client-side tolerant bridge already injected in static/js/mina.socket.js\n# Note: We did NOT automatically rewrite server socket logic to avoid invasive changes.\n" >> "$sf.auto_patch_preview"
      echo "  - Created $sf.auto_patch_preview for review (no automatic code modification executed to avoid risk)."
    done
  else
    echo "-> No socket files with emit/on found; skipping server socket auto-patch."
  fi

  # 10d) If we modified any files, show git status (if in a git repo)
  if [ -d ".git" ]; then
    echo
    echo "-> Git status (showing modified files)"
    git status --porcelain || true
  fi

  echo "=== AUTO-FIX: Completed safe, non-destructive patch steps. ==="
else
  echo "=== INSPECT mode: No code changes performed. ==="
fi

echo
echo "== END MINA V10 DISCOVERY =="

# Print instructions for agent reply: paste the entire console output here for the CTO review.
echo
echo "==== COPY ALL OF THE ABOVE OUTPUT AND PASTE BACK TO CHIN/CTO FOR NEXT ACTIONS ===="